Good class, make sure you're interested in and capable with the material though.
If you are a CS concentrator, take another, more interesting and more challenging class (such as CS 61) while you take CS 51.
Take this course if you are willing to work a lot!
Be willing to work hard
ONLY take it if it's required and you have never worked with functional and object-oriented programming before; otherwise, it will be a waste of time and an exercise in tedium.
The problem sets can be lengthy (comparable to CS 50 if you entered the course with limited experience) but quite doable, and are very satisfying when completed.
It's not an exciting course. But you have no choice.
Challenging, but you learn a lot
It would be much better to take 6.001 or 6.170 at MIT instead, if they were still offered. Instead, Harvard students are left with an inferior substitute.
I only took this course because it was required, and you should only ever take it if you're required to as well.
CS51 is a course with a lot of cool concepts, Scheme especially, and a number of very cool problem sets. It's also a course in which you're expected to learn and produce a lot within a small time frame. It's a great further introduction to computer programming, but lacks substantial support for newcomers, something that might encourage more people to do more CS.
It's not as easy as it sounds.
if ( you.have == "creativity")     you.will_like_this_class();if ( you.like == "candy")     you.will_like_this_class();
It is not quite as fun as CS 50, but makes you think harder and in cool ways.
It's a good course, but not as good as CS 50.
the problem sets are unattractive and long, lectures are not very useful, however after taking this course you will know scheme and C++ as well as how  to come up with abstract structures
only if you're willing to work.
if you were in the bottom quarter of cs50, don't take this: there is less extra help available, less time to fall behind.
It will use quite a bit of time!
Only take this course if you are concentrating in CS and must take it.
While the course does teach many interestind and useful things, the percentage of time spend on interesting things is too low to make the course worthwhile (unless you need it for a concentration requirement).
Raytracer!
be ready to work a lot.  Also it is helpful to have a lot of background with computer science
Good course that introduces you to the basics of object oriented programming and larger ideas of abstraction.
I recommend this course ONLY IF you are a CS Concentrator or are pursuing a Secondary Field in CS.  Should not be taken as an elective.  Be prepared to do a LOT of work.  For partner assignments, definitely switch if you are not happy, switching helped me tremendously.  Sections are more useful than lectures surprisingly.
I thought it was a very difficult class, lectures weren't particularly helpful, but learning C++ is useful, and some of the problem sets are fun to do (if you're not using up your entire week on them).
Recommend for anyone interested in programming. Scheme is one of the most incredible things you can learn here.
Although this is a great course for furthering one's computer science knowledge, I found it overwhelming at times to keep up with the problem sets and all of the material.  Be prepared to dedicate a lot of time to this class.
It's required for CS concentrators. If you're planning on working with me in other programming classes, you'd better have understood what this class requires.
I would say that this class is a very fun introduction to higher level programming and that there will be lots of assignments with very tangible results.  I would say that one might potentially find it to be a high workload class, but it depends greatly on one's aptitude and it is impossible to tell how time consuming the class will be on first appearances.
If it is part of your requirements for your major, live through it with a friend, otherwise don't go anywhere near it
If you like computer science, this is probably a good class to take.
I would recommmend it only for concentrators in computer science and those interested in learning C++
I would recommend this class on the strength of the Scheme portion and its wide relevance.
Challenging but worth it if you really like computer science and plan on working on large projects in the future.
Unless you're a programming wiz, expect to spend many hours in the science center terminal room.
If you like challenging problem sets and want to learn to program, it's great.  Don't expect to enjoy lectures though.
There are a lot of interesting things in this course, not all of which you will enjoy but ultimately will be enriched for the better by.
I'd say don't take this course unless you plan to concentrate in CS. Be prepared to work! Don't skip any readings. Review after each lecture and ask questions to keep up.
You'll learn a lot about abstraction and design in programming, which were very interesting to me and made me feel more like a programmer; you'll also get good coding practice from the problem sets.
Read the bulletin board. Post to the bulletin board. Worship the bulletin board.
Take the class because you learn C++ and design, but the class wasn't particularly enjoyable because I spent a lot of time feeling very frustrated by poor explanations.
It's a lot of work, but you learn more about what programming is actually like.
Don't take this class - CS50 is a great course, and CS51 is nowhere near as good.
Content good but lectures not so relevant. Ended up doing most learnign on problem sets.
Only take this class if you have to.
Students need to be ready to get answers to their own questions by trying things and by looking online. Otherwise you will become very frustrated quickly.
Be careful on the midterms.
Don't bother taking it if you thought CS50 was painful and moderately interesting, because its definitely not as fun.
You will spend half the semester learning a language that no one uses (Scheme), and the other half rushing trying to learn C++ so that you can write very challenging code in it by the end of the semester.
I would tell future students that unless you want to be a cs major, you will not be very interested in cs51. I could have taken CS or physics for my concentration, and I regret not taking physics.
Interesting and useful (I am certainly a much better programmer after taking this class). Requires a lot of time spent debugging (which should not be a part of the course) and can be frustrating in terms of evaluations.
take cs61 instead, this course is boring, the teaching staff is boring, and the course material learned is often intuitive and not very useful, only take if you are a compsci major and must fulfill requirements
There is nothing in this course that isn't just as well learned through Google and a bit of plodding. Find a good project to work on and skip this one.
Arguably the simplest chance to learn certain 'must know' programming concepts such as abstraction, and OOP.
The material is valuable to learn and know, but the class itself isn't anything special.  Lectures are bland, TF's are distant, and the problem sets can get very tough.  Pair programming with assigned partners can be frustrating if you're stuck with someone incompetent.
a necessity if you are a computer science concentrator. for those seeking a secondary or just wanting to learn more computer science after CS50, take CS61 instead.
This course, while not as practical as CS50, offers a very good introduction to the more theoretical aspects of computer science. In my opinion, taking CS51 is the best test of whether computer science is right for you. I recommend it to anyone interested in the theory of the discipline.
I would tell them that this course is well taught, and very useful for learning about higher-order functions, functional programming, etc.
take it only if you are sure you lie computer science
Essential for students interested in possibly pursuing Computer Science, but limited appeal outside of that.
great and funny lectures, good breadth and depth of material, really useful in practice, not only to computer scientists. I'm an enineering concentrator and taking cs51 helped me save A LOT of time on some engineering assignments, esp. with data processing.
They have to have the time to devote to the class, but if they do it will be worthwhile and interesting to learn a new way of thinking about problems.
The class is a whole lot of work, but it's a prerequisite for a lot of CS classes, so it's kind of necessary.
It is pretty unorganized and the work load is just tremendous.
if the work is toned down and you realyl want to do tough CS
they worked out a ton of bugs last year so I'd assume it will be better next year.
If the teaching 100% in Scheme thing is changed, I might actually recommend the class. Otherwise, no dice.
in future years, cs51 will probably be more organized and better run.
This is a very challenging class, but it will teach you to think in really interesting ways.
Assuming you're into computer science, this class is an excellent asset to your knowledge. You may not like or understand the implications of functional programming or the importance/application of recursion now, but you will understand and wield its power with the fury of a thousand dragons after taking this course. Also, Greg Morisett rocks.
Learn Scheme -- it's cool.  Course was pretty good this year -- it's bound to get better from feedback.  Workload is pretty manageable, and even this should get better as the staff learns to optimize for maximum pedagogical effect per hour spent on the course.The only problem would be if you don't like learning in a lecture format.  If so, you're kind of stuck because there is no real textbook for the course.  It's either understanding the lectures, reading the lecture notes, or going to section/office hours.
Unexpected amount of work. Not that well taught/explained. But definitely good skill to have.
Do not take unless you're a CS concentrator; it has no practical use to anyone else.  Also, be prepared to deal with an annoying/almost useless language.
While CS50 is about programming, CS51 is about computer science.  Take the class if you'd like to learn a new way of thinking about problems and code.
Only take this course if it is better organized next year.
This is a great course for anyone with an interest in computer science.
extremely interesting if you want to learn more cs, but incredibly time consuming
This is a really well-taught class and you'll really learn to appreciate computer science, as distinct from plain-old programming
do not take the course unless you are prepared for a very high workload; do not treat 51 as if it were cs 50; the support structure is not the same.
CS 51 is a great introduction to *good* programming - a much harder task than most think. The class also presents future topics and can show a student whether s/he would be interested in continuing in computer science.
Greg Morrisett is an excellent professor and this course is great for anyone who is interested in computer science. It isn't as exciting as CS 50 but is still a great course. It might still be considered too "basic" by those with lots of early CS experience but it's great for the rest of us.
this course teaches not only things that are useuful right now but also things that will be very useful in future. This course has a vision!
Unless you are not taking any classes, this class is just not worth it..
Sigh. So I'd actually be "likely to recommend" this course if not for the way all the concrete aspects (ie the awful projects, the needlessly grueling 2-psets-a-week schedule, the general disorganization) were handled, because the course material is interesting and cool and definitely stuff I'm glad knowing, and the professors and TF's were wonderful teachers in that regard. But all the concrete little details were handled so poorly that I really have trouble recommending this course.
It was so badly organized. Don't even think of taking it unless it is required for your concentration.
The material was interesting but the way it was run was extremely disappointing.
CS50 teaches you how to program, and both CS121 and CS124 teach you theory. CS51 is an awkward middle-zone that does neither very well.
This class is likely to get MUCH better next year and I really wish I'd waited to take it. So, take it!! Greg M is amazing.
The material is fun and worthwhile, but the course staff didn't put in that much effort.  If you'd find sloppily-written assignments, buggy exam questions, and psets returned several months late frustrating, make sure the course staff are committed to putting for effort into the course than then did my year.
Hopefully it'll be a huge improvement from this year.
The course could be very interesting and rewarding, but only if improvements are made to course administration and to the depth of material coverage.
Do not take this class unless you must. Much of the material overlaps with CS 124, and you can learn Scheme on your own. Professor Zabih in particular is incompetent and unenlightening, rendering about half of the lectures completely meaningless.
It took a lot of work and the projects were often confusing and sometimes full of bugs
DO NOT TAKE THIS CLASS. DO NOT TAKE THIS CLASS. DO NOT UNDER ANY CIRCUMSTANCES TAKE THIS CLASS. Unless you want an impossible final where the mean was a D+ (69.36), problem sets that have tons of bugs, clueless TF's who not only don't know what's going on but fail to hand problem sets back until EXAM PERIOD, absolutely useless material that you will not use ever again unless you take CS 152 or 153, and a GPA deflator, then stay away! This class is NOT CS50 part II. I don't care how much you loved Malan and CS50 (as I did); you have been warned!
Take it!
If they reduce emphasis on Scheme and functional programming, go for it.
Great information, taught poorly. It's a tradeoff.
The revamped version of CS51 is great and surprisingly sophisticated in terms of some of the algorithms it teaches. It is a very engaging course and I highly recommend it.
To be prepared to spend a lot of time working for the class, and that the class will be a lot more organized in future semesters, so it will be better and more enjoyable.
Good intentioned, but a mess.
Greg is a great professor and though the language seems useless at first, it's actually very cool. Two assignments per week can wear you down...
the course is hard and very time-consuming, and requires great dedication, but at the same time it is very rewarding. And the professors are lots of fun!
There are two problem sets per week, so be prepared to work.  But you will learn a lot about how to write elegant and useful code.
Take this class. It's good. Trust me.
DON'T TAKE IT!!! THIS COURSE WAS THE MOST DISORGANIZED COURSE I HAVE EVER SEEN AND I ONCE HAD A TEACHER WITH ALZHEIMER'S!!!
lambda is your friend, and remember to close all of your parens.
Not so bad of a required class for CS; otherwise, only take it if you are really passionate about CS but not about a specific topic in it.
Hard to say, it's still good to program I guess. But the course itself was a giant giant mess.
If you ignore the organization and feedback issues and the excessive workload, then you have a very interesting course.
CS51 teaches you to think more clearly about program design.  The partner projects aren't as painful as they might sound, but do be aware that it's like having two problem sets a week, since there's usually a project checkpoint due within a few days of a pset.
Even though I already had a fair amount of CS experience, this class introduces a ton of material that I had never seen before. It was quite a bit of work, but it was always fun and/or rewarding.
take it if you have good amount of time in your schedule
It doesn't teach what it is supposed to and it is the most poorly run and disorganized course I have ever taken. How this could happen at the best University in the world is absolutely beyond me.
You can take this without 50 if you took APCS in highschool or equivalent background. Really cool course, you can do the psets without going to lecture, but study hard for the tests.
I believe this was the second year of OCaml and Java, and it's a great way to frame the course material. You definitely build so much on the base established by CS50. Take this class! Moo!
This class is a great next step from CS50.  The psets are fun and interesting.  Moogle was incredibly rewarding.  The TFs are great and OH's are really helpful.  Just keep in mind that there is both a final project AND a final.
The course is great, but conceptually difficult.  You won't learn as much programming as you might think.
If this class is taught in Java again next year, you should probably do some Java before coming in to this class. The class does a very poor job of teaching Java, but it's GREAT in teaching functional programming and OCaml.
Take this class if you enjoy programming - simple as that. Prereq for most upper level courses, and well taught to boot. :)
CS51 is a bit harder in concepts than CS50 but less time intensive. It also provides a very nice overview of all the basic CS concepts that were not covered in 50. You should all study CS and you should all take this class.
Work hard on the problem sets, especially the testing, because it's not enough just to have it sort of working, it has to be almost perfectly bug-free and well written code to get a great score.
Great class. Taught well. Professor is excellent.
Ocaml is like math.
Take it if you want a secondary/major in CS, learning to think functionally about programming is a necessity.
This class is a great introduction to functional programming. It's very reasonable, and Professor Morrisett is great.
It's a lot of work, but not much compared to other CS classes. It's basically split into two parts: Java and Ocaml (Object Oriented and Functional programming). Even if you know the languages before taking this class, it's still a challenge because the problem sets require a lot of thought to find the best way to solve the problems. The only thing two things I didn't like about the class were the fact that there's a final exam and a final project, and that they didn't teach much of the Java library, which is really the best thing about Java. Drop the final exam and talk about things like ArrayList, HashMap, LinkedList, etc. and this would be a very good class.
If you don't understand recursion, learn it!
This is a great class to take, and as a CS concentrator, it's pretty much necessary. However, I would be wary of even believing that the view obtained from the course is objective. There are clear preferences on the side of Greg and the staff for functional programming, and imperative forms of programming like Java seem to get shafted.Simply put, it's perfect for depth exposure to functional programming. For Java/OOP, unless you've taken APCS already, not so much.
The class is a lot of fun, and I didn't find it too hard. Do make sure that you actually want to learn functional programming before you take the class, though.
Don't bother taking this.  It's not hard and your time is better spent in other classes.
The class is interesting and rewarding but if the only thing you took before this is 50, then it's VERY difficult unless you have a really solid math background, in which case it's still difficult.  Be prepared to spend a lot of time on it.  You'll learn a lot and it exercises your mind in interesting ways, but it's really really tough.  Don't get discouraged or allow all the terms to mess you up - they're really simple; I sat in lectures constantly googling definitions and it worked out (I rewatched them later, taking notes then, which was much more effective).  Get some really skilled coder friends to help explain things you don't understand because you'll need it - the support system is there, but not incredibly strong.
You'll quickly realize that you're not in cs50-land anymore, but the Wednesday and Thursday night office hours in the SC might seem familiar. It doesn't take as much time, but the material learned in each week seems denser. Overall a good course, and Greg's a great lecturer.
This may be the best computer science class you will ever take.  It inspired me to pursue computer science as a concentration and research area.  Professor Morrisett is an outstanding lecturer, teacher, and person.  TAKE CS51!
definitely take it if you have any interest in computer science beyond the level of cs50. it is tough at times, but worth it in the end.
Make no mistake--CS 51 is not CS 50.  It's much more time-consuming and "serious" course without the bells and whistles of 50.  But you'll probably also learn more than in CS 50.  Every so often when we did a problem in the ocaml portion of the course I found myself smiling at how clever a solution it was.  Constantly coming up with clever little ideas goes above and beyond what CS 50 asked for, but you'll find it's also much more rewarding.
Abstraction and OO programming are extremely important but this class isn't that well taught..
If you are interested in programming and haven't seen functional programming before, take it! Even if you don't use it, it teaches you a lot of concepts that make you a better programmer (and are extremely interesting.) Don't get scared away by the first few lectures with ocaml - I was very scared when I saw my first bit of ocaml code, but it really is not that bad.
It's a phenomenally interesting course - you'll get a much better understanding of how different programming paradigms and languages work and how to use them to build better software.
This class may seem difficult but if you put in the effort and pay attention to lectures and go to section, it really isn't that bad. But it is definitely a big step up from CS 50.
A lot of people don't want to take this course because it's an intro class and they think it's too "easy". Even if you have quite a bit of experience programming (probably object oriented and the like), this course mostly discusses functional programming, which is quite different and also more elegant in a lot of ways. It also exposes you to some higher level concepts about programming languages, through comparisons of OO and functional programming. Either way, you'll come out of this class knowing quite a bit more, so give it due consideration!
An excellent class to take if you enjoyed CS 50 and are thinking of concentrating in CS, or even if you're not and just want to see what "real CS" is like. Slightly more theoretical than 50 and more focused on writing efficient/good code rather than just the basics of programming, but not esoteric and still heavily focused on programming as far as assignments go. Expect assignments to take a little more time than 50, but still very manageable.
It is not phenomenal. It is adequate and it teaches what you need to learn, but not in a particularly satisfying way.
I took CS50 cause I thought programming would be cool. And then I took CS51, and I realized that programming is meh, but THINKING about how to program things best, especially in OCaml, is like, the coolest. Morrisett is an awesome professor with a great attitude to him that makes lecture a blast. OCaml is honestly the funnest thing to hack in (most of the time) once you learn it. I can't recall ever getting PUMPED about tackling problems for a class. But for the OCaml psets, at least, I was so excited to work through problems. So material is great, professor's great, staff's great, big fan of CS51 even if I may have screwed up a bit on the last bit of the course. Regardless of whatever I end up getting in this class, I don't regret taking it. Awesome, awesome class and material. Big fan.
Some people seem to dislike this course because of the foreignness of functional programming; I personally thought the lectures and section assignments taught Ocaml very well, and I loved the course assignments overall. The exams are pretty tricky and the final project will probably consume your life for a bit, but it was a class I was genuinely interested in.
Make sure you have a good partner for the projects and everything is easier. I can imagine the class becomes much more difficult/less fun if you either don't have friends in the class or are forced to do most of the work yourself.
It's great, Greg's a great teacher, it teaches a new way to program for new programmers.
This class is more applicable to actual programming than CS50. Prof. Morrisett is an amazing teacher and really hope you get Rob B as a TF. The final project is by far the best learning experience you'll get in the course, so make sure you pick a topic you want to work on and don't mind spending hours on.
CS51 is a great follow-up to CS50. The class teaches you how to program with style and efficiency, while introducing you to functional programming, which is seldom taught to beginning programmers nowadays.
Great class!
I now have an appreciation with all aspects of computer science from languages to programming to the commercial process that goes along with it. Gained both perspective and hard skills. Also Morrisett is a fantastic lecturer and professor. One of the best at Harvard.
Yes. ML can get pretty funky (and yucky) though
Take it. (If you like CS)
There is a lot of work, much of which may not be rewarding.
CS50 lectures: fun but you learn by yourself. CS51 lectures: boring but Greg actually teaches you stuff. I enjoyed CS50 more, but CS51 is a class worth taking.
The course is great, I learned a lot of Computer Science principles (NOT programming, but actual principles). The psets were graded a little harshly sometimes, but overall a fair, fun course.
You get a good idea of what CS is like.
you need to be serious about learning CS. as Greg states over and over in class, this is NOT CS50. It's a whole different ball game
The course complements CS50 well in introducing you to basic principles of computer science and programming and is worth taking after CS50. It definitely expands your ability to learn more in CS.
This is a much better introduction to CS than CS 50.  If you're unsure, take it.
Cooler topics then CS50.  This is where you actually learn how modern software development is done.  Time consuming but definitely manageable.  Don't expect to come out of the class having mastered any specific programming language, but instead understanding the core ideas and tradeoffs involved in software design.
A great course to take if you've taken CS50(and a little easier, I felt). I felt like I actually took something from this class. My only advice is that students should prepare ahead of time for their final projects.
This class is fantastic! A little more difficult than CS50, but definitely take it, even if you're not doing a concentration or secondary in CS. Greg Morrisset is an amazing professor, and the problem sets are really fun to do. The midterm and final are pretty tricky. Just make sure to pick final project partners who are CS concentrators, are taking the class for a letter grade, are good programmers, have taken CS50, respond to emails, and actually care about the class. I learned my lesson the hard way.
This is a great class for an introduction to functional programming. A lot of cool concepts were brought up.  The psets were ok; they could be extremely unclear/confusing at times but the problems themselves (once you finally understood what was being asked) were good.  Also, the teaching staff was a bit slow to get graded assignments back.
Make sure you have enough time for this class. Taking this class with CS 124 is difficult and really unnecessary. I regret doing this.
Don't get the textbook, you won't need it. If you have some background in CS, this class can be rather easy.
it's a good class, much more well-run than (apparently) previous years' versions of cs51. the psets are pretty fun but there's nonetheless a lot more 'real' coding than cs50, i think; in fact, i actually enjoyed cs51 more. on the possible downside, there are a lot of kids who find this class really easy, and if you don't have a ton of programming experience, you might find the curve a bit steep as a result (esp with the exams' grades). i'd only ever taken cs50 and felt a bit overwhelmed at times; psets took me between 5 hrs (an occasional good week) and 15 hours. overall a surprisingly good class, but not a walk in the park.
Great professor
Get ready to be angry and frustrated.
If you liked CS50 a lot, think about taking this only if you have a solid understanding of programming and are able to pick things up really quick. If however, CS50 was hard for you but you still liked it, then think long and hard before you take CS51. It is a big difference in pace and depth than CS50. If you don't have a solid programming background, you will find yourself spending 12+ hours on each problem set and at every office hour.
It's a requirement. Take it if you have to. Otherwise, go take some other more interesting coding course.
A must-take if you are considering concentrating in CS or just want to get better at it.
Only take this class if you're willing to work hard and you have a lot of free time to devote to it.
This is a goods course, but don't take just because you thought cs50 was fun.  This programming is much harder, but if you like cs then it will be worthwhile.
it's a lot tougher than cs50
Not the most challenging class, but it reinforces good design practices you will probably benefit from for the remainder of your programming career.
It is helpful for improving your programming skills, but it is a lot of work.
I wanted to like this course. Unfortunately, a frustrating grading system and the course's slow pace all but ruined it for me.
Good introduction to OCAML. Take this class if you want to learn better coding practice. Be aware that some things like commenting are forgotten about.
study hard for the midterm and final!
CS51 is an excellent course and I'd highly recommend it.  Though more difficult than CS50, you will walk out of this course with significantly more confidence in learning new languages/tackling higher-level questions.
This was one of my favorite classes at Harvard and is extremely well taught.  If you have the slightest interest in CS, you should definitely take this class as long as Greg is teaching it.
CS51 is a very instructive course. It introduces you to basic programming practices so that you learn how to code well, not just throw stuff at the screen. It also helps you reason about programming and understand why certain aspects of programming are important.
You will definitely feel pretty badly about yourself after taking this class. In CS50, I felt like the paradigm was "you need to put in a lot of time, but you'll feel really accomplished afterward." In CS51, the class required as much if not more time, but there was never any real feeling of accomplishment. 20+ hours a week and still being totally average in the class feels pretty crappy. But, total confidence destruction aside, the course material is fascinating and worth learning.
If you've taken CS50 and enjoyed it, I would urge you to think twice before you take this class. Do not take this class if you are a freshman without an already well-honed talent for mathematics or logical reasoning. The material becomes quite advanced very quickly and much of the advanced material in psets is only lightly touched upon in class. Do not take this class unless you are extremely confident in your ability to think abstractly about computer programming.
Definitely valuable for learning functional programming, but OCaml is not that worth knowing unless you plan to interview for Jane Street. Functional programming the context of Javascript, Python, or Ruby is probably more useful in real life. Using ML to learn functional programming was definitely valuable though, and teaches you a lot about cool abstractions.I didn't feel like this class taught Object-Oriented Programming that well, but they did a decent job. Java was not taught very well this year, in my opinion. I feel like the teaching staff added on Java because it would be a good language to teach OOP in (it is), but they didn't have very much experience with Java beforehand.Overall, if you feel very comfortable with CS and/or have more CS background than CS50, then you shouldn't find this class very difficult or time-consuming.
It's a lot of work, but if you get started early, it is very doable.  It's certainly not a GPA booster, but I really enjoyed functional and objective programming.  Make friends with the TFs and GO TO OFFICE HOURS!!  Programming is definitely a skill worth learning.
The difficulty of this class really depends on the level of experience of the student coming into it. Of course, and beginniner, like myself, is going to struggle a lot more than someone more experienced. You'll have to put in more work and effort, and that may be frustrating but you'll end up a better programmer. That being said, the problem sets ARE very doable for beginners as well. Just go over the lectures, and actually do the problems at the end of the slides. Also, go to office hours if you're stuck. And start the psets early. I'm not kidding, just chip away at it every day.
Functional programming is probably more interesting than you think.
lectures aren't very great, there are a few that are interesting. section is definitely helpful, attending will help in understanding the concepts that aren't really well taught in class.
Great course. In my opinion a lot more fun than CS50.
Great class, definitely recommend it! Don't shy away because it's OCaml -- the OCaml part is actually much cooler than the Java part.
An absolute must for anyone interested in coding, but requires a lot of time, and the grading is harsh.
Start on your final project early on!
Don't hack. When Greg says you should reason about code, he isn't kidding. The class isn't too hard if you actually take the time, before typing anything, to think what is going on and how you should contribute.
This class is not too difficult, but definitely a must for anyone with even moderate interest in computer science. This class is not about coding as much as it is ideas, and the concepts it teaches are both interesting and essential to any developer. This is what separates script-kiddies from real developers.
If you're majoring in CS this class is indispensable (and required so I don't need to tell you this). If you're not majoring in CS but are just interested I would still suggest this class. It will deepen your understanding of the challenges of programming, both to make you a more conscientious coder and (perhaps more importantly) a better judge of others' code. And regardless of programming, it will challenge you to reason differently and more completely about problems.
No background knowledge of cs is necessary other than cs50. however, be warned the vast majority of students have had a lot of prior experience with components of this course. It makes it extremely hard for students with no prior knowledge to keep up.If you have no prior experience office hours will be your lifeline. Go to as many as possible.
Less brute work, more conceptual difficulty than CS50.
The course itself is still slightly unorganized, but the class is very informative and you actually learn computer science. If you really want to learn about what makes CS tick, take this class, but expect some tough assignments. Also, start working on your final project ASAP. It is definitely better to get as much out of the way.
Greg is a great instructor and some of the course staff tend to be quite good. The course teaches to the lowest common denominator, and there's no more comfortable section so theres probably less to do for the more capable than in cs50. My year they had to waste a lecture going through make files because people couldn't use a man page and understand how they work.
If you have a lot of time in your schedule and want to become a competent programmer, this is a great class.
Awesome course. Good for Computer Science theory
Never went to lecture and I do pretty well. But if you do go to lectures I heard they are really fun. So win-win both ways.
It really teaches you the way to think CS like. A lot of higher concepts were introduced. OCaml is very cool too.
This is a great CS course. But--and here's the one caveat--this is definitely not CS 50. It's especially shocking after you get out of the hand-holding, utopian CS 50, where David Malan's wisdom flows freely like the nectar of Zeus. No, no, Morrisett throws you into the mix right away. Perhaps they should ease you in better, but this course separates the men from the boys. Functional programming is useful. Not entirely practical, but it makes you think a certain way, which is good.Should you take this course? Yes. Will you like it every minute? No. Definitely not. But you'll like having taken it after the fact. Oh, and get to know Morrisett. He's definitely one of the coolest, chill, funny, smart guys at Harvard.
If you are interested in learning about CS, take this class. Extremely useful to learn about functional programming as the lessons are broadly applicable.
It is very well taught. But think HARD if you are considering taking this as an elective. If you are not already quite versed in CS or gifted you will probably not get a very good grade, and it will eat your life in terms of time. You don't *need* much preparation but if you don't have it/are not extremely mathematically gifted already the kids in the class who have been hacking since middle school (and are taking artificial intelligence simultaneously) and the math geniuses (like the 6th year grad student in pure math who was also taking cs 124) will destroy you and take the good grades. Technically you don't need CS50 but you really should have done object oriented programming in the past, or the Java part will come and you will be underprepared.
TAKE THIS IF YOU REALLY WANT TO PROGRAM!  This course is hard but well worth the pay off.  Cs50 is not enough to make you a good programmer.
This class will certainly make you think in new ways, but some of the syntax and concepts will be a little hard to adapt to.
Take this class as long as you have time to devote to it.
This is the new and improved CS51. Each year, they revamp this class to try to make it better... and each year they fail. But not any more. Greg has finally got it right and this class is excellent. You will see computer science with a much greater degree of appreciation after this class. Very much recommended.
Seems like its much improved from past years. Not as intense as CS50 but the material is more challenging
It's a lot of work, but you learn useful things, so stick with it.
This was a good course that had a lot of great ideas and was overall well-executed, especially in comparison to previous years. The difficulty gets much higher for the last few parts of the class, but learning about how to be a better, more efficient programmer was worth it, I think. It's neat to have a general overview of computer science ideas that's more technically in-depth than CS50.
If this class was taught like it was this year, you can safely ignore earlier CUE scores. The transition from CS50 to 'real' computer science has never been as seamless.
Hard!
This is a very solid course. The teaching staff is very good and the material is relatively fun. It doesn't have the CS50 atmosphere but it's still fun while getting you into real CS. You learn useful languages and crucial coding skills.
As is always the case with CS, start the P-sets early and you'll be fine. The course is well-taught, not too stressful; the problem sets are great at teaching you how easy/fun it is to think elegantly.
Provided that the final project requirement gets revamped somehow, this class would be absolutely awesome to take.
The project component of the class is very annoying.
I liked the class, but it really was useless. They made it a lot better than it was before, so I recommend it as a requirement, but NOT as an elective.
A lot of fun but make sure you have the time to devote to it.
You definitely learn a lot. A great course. I think Greg is taking his sabbatical next year though, so it might be restructured again. Hopefully the one teaching it next year doesn't change very much.
Give the class the time it needs, and you'll be fine.
it's hard but fun
Make sure you are sort of familiar with Java syntax.  They don't really explain that that well in the course, because they want to get beyond syntax and focus on the ideas of Java.
You come out with a new view on programming and a new toolbox to tackle problems with.  The class is run moderately well, and they've changed the language to OCaml and Java, so it seems to constantly begetting better.  Either way, it's required for the concentration and very useful if you want to program/solve problems.  It goes much deeper into the actual science of programming than CS50 and stresses elegance more than functionality.  I definitely think this class is worth it.
Lectures can be very hard to get through.  It's probably more productive for you to read through the slides on your own.  Don't really recommend wasting your time learning OCaml either, but the Java is worth it.
Material was interesting, and Prof. Morrisett is a fantastic teacher. The problem sets were actually fun- not too hard but would get you thinking. This invitation to actually use our brains- what a welcome respite from the rest of Harvard! The best class in my 3 years here. Recommended for anyone.
Challenging and interesting.  If you're seriously interested in computer science, this class is worth the time.
it's a good class and greg is an awesome lecturer, but be prepared for a lot of abstract examples that can be difficult to grasp.
This course teaches you how elegant and flexible programming can be. There is very little "clever" code, but there are a great many reusable and extensible techniques that will make programming seem natural rather than arcane. It is a great way to get one thinking about the general procedures and architectures rather than for-loops. Plus you do a lot of very cool things, like make a computer algebra system, and it's not even that hard once you know what you're doing.
This is an excellent class!  It's exciting to refine your programming skills and learn from an enthusiastic instructor.  The course has been carefully considered and the Ocaml/Java structure worked well.
The course requires consistent effort.  The final exam is deadly.
cs51 begins to venture into what feels like real cs. unlike cs50, it is not for everyone. however, you will exit feeling like you have a better appreciation for programming.
Don't slack off and use the TFs as much as possible.
Be ready to work hard.  Ocaml is really strange at first but gets easier after a few weeks.  Lectures are important, but office hours are way more important and helpful.  If you start the problem sets early you should be fine.  Be aware if there is a final and a final project--this could make studying for the final incredibly difficult.
It's a hard class, but if you keep up with the work it will be fine.
Greg Morrisett is a brilliant individual and a captivating lecturer.
clear your schedule
This class is very unorganized, and not as fun as previously imagined. Also I would have preferred having problem sets to learn the material instead of a final project.
This class is a far cry from what it used to be like in years past (at least I think so, based on what I've heard). It's much better organized and will hopefully get even better in the future. A lot of the fun/show-like aspects of CS50 are done away with in this course, but the material becomes even deeper and more interesting. If you aren't that interested in CS, you may not like it. Otherwise, you'll enjoy the deeper knowledge you gain of design and development.
Great class, but tons of work.
It's a good class for students not used to working with larger projects requiring higher levels of abstraction
Even better than CS50! Take this if you're serious about computer science.
Very interesting and useful material, but its a substantial time commitment each week.
Morrisett is awesome.
This class shows you what majoring in CS is like. Ocaml is great, the first project is not pleasant and Greg's sarcasm makes the class.
This class is interesting and generally not a lot of work.  I'm very happy with my decision to take it (as opposed to my decision to take CS 50 last semester, which I very much regret).  The only note of warning is that despite very short problem sets and easy exams, the projects take up a very large amount of time.
Tougher and less flashy than CS50, but definitely a very solid introductory CS course.
Be ready for the expectations from CS50 to rise dramatically.  The class as a whole is significantly harder, but it is worth the effort.  Don't be shocked, however, if they start falling behind on getting problem sets back to you.  Also, don't be overwhelmed when on the first day of lecture you are blown away by some bizarre syntax (if you happen to be doing ocaml like this year, don't be as blown away as I was by "let x =" statements and the "interactive" style of the ocaml toplevel - it isn't nearly as impenetrable as it seems at first).
It's definitely not CS50, but it is no way a lesser course. It was a lot of fun and Greg is a fantastic lecturer. He really knows what he's talking about and then some. Though assignments are a lot more daunting and OCaml requires a different level of thinking that you didn't get in CS50, it's definitely great for those that want to know more about abstractions and functionality.
This is a fantastic course because not only does it introduce you to functional programming (which is awesome), but it actually gives you a feel for what programming in the real world is like.  As long as you know basic basic programming (i.e. what an "if" statement is, or if you've ever used R or Matlab), I would recommend skipping CS 50 and jumping straight to this one.  This was the first CS course I've taken in my life, and I was able to keep up just fine.  Moreover, I probably learned more in this class than any at Harvard.
This is a difficult course, but probably necessary to be properly prepared to continue in CS.
Great class to take your Computer Science knowledge and skills up a major level.  Be prepared for a few 20+ hour work weeks during the semester.
How much you get out of this course depends entirely on how much effort you put into it to really learn and understand and put into practice the design principles preached. Also, do as much of the section problems as you can (I wish I had done more to prepare for the final)
This will change you from a computer programmer to a computer scientist. Necessary to learn how to properly design software and elegant code. Functional programming is incredibly cool and will change the way you approach solving problems.
Heavy workload.  Good class though.
Amazing class. Definitely not CS50 because there's less of a support structure, but it's a good test to see whether computer science is right for you. GO TO CLASS. There's a high correlation between doing well in this class and actually attending it. Also, START PSETS EARLY. Start them by Monday if they're due Friday. You'll save yourself a lot of trouble.
This is an extremely interesting class with useful concepts for actual programming. You'll learn a lot about how to code well. However, the problem sets are long and some of the concepts are unclear. This class takes a lot of work.
This class is (almost) worth taking to learn OCaml: functional programming is elegant and challenging and will be especially appreciated by those who have prior coding experience.  However, the professor is unnecessarily caustic and judgmental in his lectures, which are honestly not particularly informative, and the attempt to throw in object-oriented programming near the end was quite confusing.
CS51 is awesome and so fundamental to any computer scientist. I almost didn't take it thinking that it would be "too hard," but it is very accessible to anyone who is wiling to learn. It is WAY less bombastic than CS50 - you get straight to the material. Doesn't try to convince you CS is awesome - you realize it is awesome from doing the material. Great fun and super interesting. Loved doing the final project. Morisett is awesome - unfortunate he will not be teaching next year. Made me wish I was a CS concentrator. TAKE THIS CLASS.
You'll get good at OCaml, I guess, and programming.
Great course and a must-take for anybody seriously considering any type of programming in the future, whether it's for a computer science job or just writing a script for a non-CS field.Ocaml is a bit funky, but a great way to learn functional programming. Even though it's rarely used, functional programming is a really neat type of programming that requires a new way of approaching a problem, and forces you to actually think about the problem rather than just "throwing shit at the screen".If you've already had extensive experience in programming in an object-oriented language (like Java), then most of the p-sets will be straightforward for you.
This course is difficult, but a lot of the problems are interesting to solve rather than being tedious.
If you loved CS50 but want to get CS experience in a much less flashy way, this is an awesome class! It is more challenging but super rewarding, and you will learn so much about what good coding is. Also you will get a really solid grasp on abstraction and recursion, and also OCaml is awesome.
You should take this class! It can be a lot of fun when you put your head into it. Go to lectures! Those are very useful! Honestly, I'm not sure what the course is going to look like next year because the professor is changing but if the next one is anything like Greg you should take it! Not a class for the faint of heart but you can't be a serious CS major without taking it.
Cool psets and material. Doesn't hang you up on syntax like other CS classes. I usually spent a weekend doing the psets. Definitely recommend.
If you were very comfortable with CS50 or are very into Computer Science, this class is indicative of where you'll be going if you continue with CS.
Be prepared to put in substantial amounts of time frustrated with minor bugs in problem sets.
Go to lecture! Go to office hours! Go to section! Read over your notes!  This is a class for which you cannot do too much extra work, everything will help in the end. Also, definitely have a coding buddy or circle of friends, doing the partner psets alone is a horrible, horrible idea.
If you took CS50, and you're at all considering doing CS or programming later , it's probably a good idea to take CS51. CS51 does a good job of building upon the basics to teach what actual programming requires and is like, a picture that CS50 does not give.
I enjoyed this a lot more than CS50 because I felt that the topics covered were interesting to think about and that the material was presented without unnecessary pizzazz.
This course changed my perspective on CS. I enjoyed learning about the different paradigms of coding and how each has its own advantages and disadvantages. The course is very time consuming, but I thought it was totally worth it in the end. Just make sure to start the psets (at least) a few days before they are due.
Be ready to dispel all your notions about good programming, and revamp your style and thoughts about computer science.
Grading and expectations are not as clear as they are in CS50, and unlike what many people mention, I never really fell in love with OCaml. However, functional programming is a good topic to understand overall and you will become much better at recursion and go into greater depth with topics touched on briefly by CS50.
Decent class. Psets can be long, much longer than CS50 psets, but are not particularly difficult to understand. Midterm and final were also reasonable.
CS51 will break you down and build you up. Also, it's harder than you think it is.
If you're prepared to put in a lot of work, this is a great way to better your programming thinking and skills!
A decent class, but be aware that there aren't many resources online for Ocaml, the relatively obscure functional programming language we use in this class.
It's tough class, but OCAML is a pretty elegant language, and it'll get you to think about your code before writing it, which is a good habit to have.
This class is a MUST TAKE for any student who is either going to concentrate in computer science or just wants to get a brief exposure to the subject.
NECESSARY if you are thinking about concentrating in CS. Will let you know whether or not you really want to concentrate in it (CS50 is kind of idyllic). Will teach you how to code better, Morrisett is a great lecturer.
This is a challenging but overall fun class.
This class takes more time than you think it will!
Be prepared to work until your eyes bleed.
If you know a lot about programming, like inheritance, data structures, and general programming familiarity, you could probably skip it. Other than that, it's a decent course that really just picks up where CS50 leaves off.
This course is difficult, but rewarding.
Functional programming is almost certainly going to be an important skill to have, so I would highly recommend learning it in some form (especially if you are a cs concentrator). For that reason I would definitely recommend CS51. That said, I have some reservations with recommending the class.  If you already know Object Oriented programming, the second half of the lectures are not incredibly informative. In addition, the problem sets were almost entirely graded using automated tests. I ultimately felt like I learned a lot, but didn't have much support from the course.
It's hard but doable.  This is real CS and it will absolutely change the way you think.  I had much better friends in psetting than in CS50 in part because you'll see the same people at office hours.  The TFs this year were all phenomenal.  I can see the traits that might cause some people to not like Greg, but I thought he was great.Also, in the first two weeks of class, make sure someone tells you the "trick" of recursion.  Once you see it, it gets muuuuuuch easier, but if you try to work it completely out in your mind you'll get stuck in an infinite loop.
Must FoR All Cs Majors And Minors
Good introduction to functional programming and better style.  Also, an excellent transition to larger scale programs if you're coming from CS50.
SO much better than CS50. The lectures are engaging and useful. Even though you'll probably never use OCaml again, it's a perfect language for teaching recursion, functional programming, data structures, and many other valuable topics. You'll no longer be able to get full credit for simply having code that works, and that's a very good thing for anyone who actually wants to learn programming. 51 has an incredible team of TFs. They go above and beyond at office hours, often staying late and somehow managing hundreds of stressful students. This is a great course and not as hard as everyone says it is. Don't be fooled into thinking that taking CS50 alone is enough to learn how to program competently.Speaking of TFs, Kevin Schmid is my favorite person ever. Without him, half the class would be failing. He will do anything to help anyone in the course. His office hours are officially 2 hours, but he'll end up staying for 6 or 7. Make sure you thank him when he saves your grade for the 10th time!
the course is not easy but it is essential to learn good programming techniques.
Lot of work. Worth it.
Take this class for your secondary or concentration because you definitely learn an appreciation for higher level CS and begin to understand how challenging it could really be. That being said, it is really really really frustrating and hard.
CS51 is definitely an intro class - there's a lot of support and no one expects you to know functional programming going in.  It's more mathy than 50 (and for a lot of people this makes it more interesting/fun).  You learn a lot of useful coding skills and OCaml actually makes recursive programming make sense.
Functional programming is great! Be prepared to work harder, for more hours, and with fewer breaks (problem sets are due alongside midterm studying and the final project) than you did for CS50, but I'd say this class is better. We didn't see much of Morrisett's mean side, but the one good rant we got would have made the whole class worth it all by itself. Using OCaml, especially after you get past initial syntax problems, allows you to think about types, abstractions, and algorithms instead of low-level things like memory allocation.
CS51 is an eye-opening class and really teaches you various very important concepts in programming. It focuses a lot on coding style and understanding of concurrency. The assignments are also very intensive but interesting. I would recommend this course for anyone who continues to be interested in computer science after CS50.
This class is super intense. Take it with great care!
I found this class way more difficult than CS50, especially the exams.  The concepts taught in 51 are more of what core CS is about than 50, and I'd say 51 is somewhat of a weeder class, so be aware that it might be a completely different experience for you than 50 was, but by the end you should have a better sense of whether CS interests you or not.
I have a great sense of what constitutes elegant coding and exposure to a beautiful language, OCaml. You'll hear a lot of people telling you how terrible OCaml is, but it's actually really elegant and beautiful, so enjoy. You'll come out of CS51 a better coder if you use it to help you develop habits. The concepts here are useful not only for CS, but for anything that requires problem solving.
Do not take this class unless you are serious about programming. I'm serious. This is not fun like CS50. It will, however, make you a much better programmer. Unless you are willing to put aside 3 or more hours a day plus time on the weekends for this class, this class will break you. Basically, do not take this as an elective.
Great teaching staff. Keep up with the lecture slides!
This course was very good and I learned a lot. The assignments take a while but are not impossible and often pretty fun. The exams were pretty hard I thought and required studying. If you do very well on the exams it shows that you really understand everything deeply I think.
It is better than cs50
Challenging class but it definitely helps you learn a lot. Be prepared for the project though and think about ideas during the year and build on them
more difficulty, more knowledge, more late nights, more epicness, more tears of frustration, more tears of triumph: in every sense, 51 > 50.
This class is great for learning functional programming, but only take it if you're truly interested in the material.
Difficult, but rewarding
This is a challenging but interesting course. CS50 teaches you how to program; CS51 teaches you how to program WELL. It turns out that the latter is much harder than the former, but CS51 will push you well along the way. The Psets are challenging but always interesting, and Morrisett will help you reshape your mental paradigms of programming.
take if you're serious about coding. It breaks you down and then builds you back up again. But it hurts..... don't take with CS124.
Just an extension of CS50, but less practical to people not doing CS. If you want to do any other CS courses you should definitely do this first.
Take this course if you want to understand what legitimate (clean, well-designed) programming looks like. Be prepared to be skewered by Greg if you don't catch on quickly enough that simply hacking it till it works is not an adequate approach. Basically, if you want to take your programming to at least a semi-competent level, take CS50++. (Also, if you don't get the ++ joke, then you should probably get your intro programming up to speed before CS51.)
It's really hard: a couple psets took on the order of 20 hours to complete. Interesting though.
This class is hard. Like real hard. Especially if (like me) you didn't have any experience with cs before cs50. Expect to spend an absurd amount of time working on the psets
Start psets early. Start studying early. Be prepared to invest time in this. Don't take CS124 concurrently.
Ocaml has really annoying syntax.  Wasted more time learning the syntax rather than the concepts of functional programming.  Could have been taught in a better format.
I really enjoyed CS51. I thought the psets took a little bit longer than those in CS50, but that they were less challenging overall. If you did well in CS50 you have the skills to do well in 51. Overall the class was a lot of fun and left me feeling much more confident in my ability to tackle large software projects than CS50 did.
The psets are often frustratingly difficult and tedious.
Greg is an awesome professor! That said most of the learning happens during the problem sets. Be prepared to be frustrated at some points but in the end it will all be worth it.
This class is not easy. It will probably require some time. Great class though, and teaches you to think in an abstract way.
Not worth taking at all lectures suck homework are hard and pointless and you learn nothing useful at all. Do not take this class.
CS51 is a difficult class, much harder than CS50, but I found it to be much more rewarding. You need to spend significant time on this class, but most of the material is quite useful. I actually really liked OCaml. It is a very elegant language.
Prepare to put in tens of hours every week to walk away with a superb understanding and your worst grade of the semester. No matter how much time you put in, it won't be enough. The staff doesn't care about you, and you will be compared to a monkey flinging its feces multiple times. Don't take this class unless you absolutely have to.
CS50 was a lot of fun and very carefree. This course, CS51, however, is much more serious and (if possible) even more thought- and time-consuming. But as always, with more investment come greater rewards, and I have personally learned a lot from this class.
Good class.  Material can be hard but it's really cool to learn.  If you liked CS50, I would recommend this class because it really takes your understanding and appreciation of computer science one step further.  It wasn't that much of a stretch, but I definitely had to put the time in to work on and understand stuff.
Main thing you learn in this class is to be more thorough with your coding and understand what you are doing before you try to hack away at the assignment. It is a good lesson to learn.
Go to office hours. If you want your problem set code to work well/perfectly, you're going to be spending more than 15 hours on it, most likely, and the TFs and other students are more helpful at office hours. Exams involving cramming in lecture videos that won't be helpful for the problem sets. Problem sets are really interesting but require more thought than CS50 problem sets did. Amazing class, but make sure that CS is what you really want to focus on the semester you take it.
Take this class if you're interested in computer science. If CS50 was your first CS class, then I hope you've taken time to actually learn the material in 50, because 51 is more difficult, focused, and delves more deeply into CS applications.
Do not take this class if you just took 50 and expect to do the same type of coding. Expect to think a little, on your own, before you open your text editor. That being said, I loved everything about this class.
A much better class than CS50, this course is just challenging enough to keep you on your toes but manageable in a way that ensures you don't completely fall behind. An excellent gateway into more advanced CS courses down the line
CS51 is a class in which you will be exposed to many beautiful concepts and a beautiful language, OCaml. It can be tough, and the administrative structure of the course is not nearly as polished as that of CS50. But it's still a worthwhile and fascinating course.
If you want to do well in this course, you better be prepared to do a LOT of work
This is a great class for getting deeper into CS. The workload is heavier than 50 so make sure you enjoy writing a lot of code. The design aspect of the course is very applicable to careers outside of school as well.
Although this course can be challenging (more so than CS50), it is completely worthwhile. It teaches you the value of functional languages and makes you a better programmer.
This class is better taught than CS50. All the material that you need to know he covers in lecture and the problem sets are closely tied to his lectures.
This class is a huge, huge time commitment. That said, you learn a lot. Beware if you don't go to lecture, Greg hates that and is quite scary.
CS51 is necessary for absolutely anyone entering the field of computer science today. The professor is very forward thinking and gets you to actually use your brain. The class is mind-bending in all the right ways and takes a lot of hours, but each hour you put in, you WILL get something out. My favorite class all semester and makes me want to go more into CS!
CS51 is really very good indeed. No, you will not be using Ocaml outside of the course, and no, this fact does not constitute a valid criticism of CS51. However, assignments are in some cases rough around the edges (for example, there was a multiple-day freakout over bugs in the RSA staff code this semester). The exams are generally quite reasonable and are nicely written.Feedback is a disaster - don't expect useful feedback on your work. However, if you're the type of person who is introspective enough to self-evaluate and know when your code's good and when it sucks, this should not be much of a deterrent. If, on the other hand, you're a "I'm just going to type a bunch of gibberish and say that it's good code that just needs to be debugged" type, this is not the course for you. You will be called out on your BS. Despite this, it's a great course - I only wish I had started in 51 instead of 50.
Go to class, go to section, go to office hours, start the problem sets early, and find out what you did wrong on the problem sets at office hours
Good class. Not too hard
The programming assignments are quite fun, with many nice and cute solutions. It's a pretty good introduction to programming and the general ideas therein.
If you took CS50 and enjoyed it, try this class. However, it is very different and much more technical. You will be forced to learn at a much faster rate than in CS50, but if you enjoy computer science, then you should love all the work and frustration.
I breezed through CS50 and stumbled, HARD, through 51. Know that this is a possibility. This course is designed to make you rethink how you approach programming and as such, nearly everyone feels off-balance at some point in the semester. Knowing that would've been really helpful for me, as I just felt like I was struggling and everyone else was doing fine (definitely not true. facades, man.) The redeeming quality of this class for me was the caring, wonderful, amazing TFs.Also: in a class that emphasizes elegant design etc so much -- please take a look at the problem sets you're assigning us and think about whether you're okay with being that big of a hypocrite. Thanks.
Problem sets take an insane amount of time, like most CS classes. Exams are unfair in testing what you know and will instead test how well you can read bad code. But, solid class in building a functional programming foundation.
This class is not like CS50, but if you like programming, will be just as fun. Problem sets are quite time-consuming so try to start on them early and take advantage of office hours, which are super helpful.
The problem sets are generally very fun, and the material is more interesting than that of CS50.
If you are at all interested in computer science, especially as a concentration or as a secondary, please take this course. CS50 is not an adequate introduction. CS50 teaches you how to code; CS51 will teach you how to think and code WELL. CS51 will introduce you to a lot of new concepts and ideas you haven't seen in CS50 (for example, higher order functions, recursion, different data structures, good "cs practices") that you'll really appreciate as you do more computer science. Greg was great, and I got a lot of support from the TFs. That being said, you really have to know what you're doing because the course can move quickly, and the problem sets definitely take 10+ hours per week. Make sure you start early and budget enough time to complete all the work. The class was really tough the week before spring break, when we had a large pset due and a midterm in the same week, and during reading/exam period, because the class had a project and a final exam. Be ready for the work that you'll be facing, and you'll have a very rewarding and enriching experience.
This class is a must take for anyone who wants to take their programming and knowledge of computer science to the next level. Although I never took CS50, I found that having a lot of programming background made me appreciate this class all the more. I definitely feel there is a lot to gain from this class, and it is up to the student to really control how much they want to reap from it. One can just simply complete the p-sets, but I found that there are lots of theoretical and technical experiences that a student can put under their belt during this class if you go the extra mile, especially for the extra challenges. I definitely would say though that I observed some of my peers who had just come in from CS50 take this, and it seemed they struggled with some concepts.
This class is not CS50. Don't expect fun hackathons or music videos or crazy office hours in Annenberg. That said, if you think CS is the place for you after taking CS50, this is the class to take. IT IS A MUST! The class is extremely polarizing. Either you will love it or hate it, but regardless, it will help you find out if CS is really the place for you. You can hate the class and still love the subject matter but you'll know if you really like CS and programming. This class will most likely kick your ass but the support team is incredibly helpful. They really want to help you succeed and you will do well if you stay on top of the material and start your psets early. But actually, start psets early and really plan out what you need to do before you even touch a computer. That's the best advice I can give you.
This course to me was a lot of syntax bashing, and I feel that your time would be better spent teaching yourself oo programming and functional programming with java and haskell, as they would be much more useful to you in the future and you would learn the same things.
You'll learn a lot about writing clean code, and you'll learn a lot about how to code with others in such a way that you don't even need to see each other's code. Abstraction barriers are good. As for the final project, it might be fun to learn a new language, for the entire semester is spent coding in OCaml (The Java component was removed). Google is very helpful in this pursuit, and you might just leave the class with a practical new skill (we learned Python for our project). Also, take the documentation for your final project seriously. I mean it. Get started on that early and make it pretty. We didn't, and we paid the price for it.Be prepared to devote a lot of time to the problem sets. Furthermore the lectures, after the halfway mark, often involved convoluted examples that drove many students in the room to visit Facebook and check their emails rather than pay attention. If you go home and re-read the slides it can make more sense though. Note that OCaml is VERY DIFFERENT FROM C. I never used a loop in any of my problem sets. Everything is recursion. It's a cool language though, and the solutions to problems often involve a lot more thinking than they do typing. OCaml code is generally much shorter than C code, and its type checker keeps you in line. You really have to think about what you are doing if you want to write good code in OCaml. Professor Morrisett emphasizes this.
You'll be assigned multiple group projects. Pick your teammates wisely. Depending on that, the group project could end up being but a frustrating confrontation with your teammates, or an exciting learning experience.
This class will definitely improve your computer science skills, but be prepared to do a lot of work.
It's hard, especially in the beginning, and really discouraging when you're like me and your psets are all suddenly at like 70-80% marks. It gets better but you have to spend a lot of time working with what you know and forcing it to work with what you don't know.
It's a hard course, no doubt about it, but probably worth it.
Its really hard
This class is more challenging than you'd expect, but it is also very rewarding. This class will turn you into a GOOD programmer, regardless of your background.
It is a great class but it is not for the faint at heart.  You have to be ready to accept a heavy workload.  You will learn a lot though.
CS51 is CS50++:  the material is not rushed but rather thought-provoking; the psets are more in depth and will push you to understand the course material. This course is difficult but manageable, time-consuming but rewarding and a must for any CS concentrators.
This class is awesome.  It forces you to think about computer programming in a different way which is hugely useful.
Better than CS50 in every respect. Problem sets are both more interesting and easier. Exams are much shorter and more relevant (although quite tricky( Greg is great, so you should actually go to lecture, and stay awake through it. Group project can be kinda miserable... make sure you don't have a group where everyone has tons of other commitments.
The class is definitely hard, but the difficulty comes at only a few points in the year. There are only 7 problem sets or so, the tests are much more reasonable than those in CS50 (the final was only six questions), and the instructor is great. A couple problem sets (especially the last one) will kick your butt, so start those early.
Fantastic class. Teaches you to think an entirely new way- that goes along with functional programming. The psets were significantly cut down from previous years, so it's totally doable now with only CS50 as background, and it doesn't take up too much time.
I took this as my "fifth" class, the only one not relevant to a concentration and in many ways the least interesting to me. This was a mistake: C.S. 51 is designed to be the centerpiece of one's schedule, and I was left with the irony of putting 70% of my work into my least important course. That said, the class is fantastic. It is intense: be prepared to be broken down and built back up, and to spend ten or more hours on a given problem set, but it is immensely rewarding. If 50 teaches you how to code, 51 teaches you how to code well.
Make sure you lay aside significant time for psets. Do NOT start the later psets the day before they are due.
It's hard but worthwhile and Morrisett is the man.
While the course is definitely useful for those in a Computer Science (or maybe engineering) concentration, I'm not sure what you'd get out of it otherwise. It's not as generally accessible as CS 50 was, though if you like problem sets as difficult puzzles and have the time then go ahead and take it.
What you get out of this course will depend highly on what you are interested in pursuing. As an aspiring software engineer, the material covered in this course was valuable, even though the lectures and sections were not stellar at conveying it. The problem sets were very time-consuming, the most time-consuming problem sets I have ever done, and are enjoyable to those who are deeply interested in computer science. Thus, the course was ultimately rewarding. However, I find it hard for students to get engaged with the material and not fall behind if they do not plan on pursuing a CS-related field. Regardless, understand that this course is not like CS50 and is not tailored for the masses.
Take this with Prof Morrisett!  He's kind of a hard-a**, but I can't imagine the class with anyone else.
Prepare to spend a lot of time for this course. Psets, project, etc.
it's really, really hard. :(
Not a fun class at all, lectures aren't very helpful or exciting
This is a good course that will teach you a lot of different approaches to software design through functional programming. The course is very manageable if you're at least somewhat competent at programming. At times, however, the assignments could get tedious.
Even if you found CS50 easy, you may not find that CS51 comes so naturally. The grade of competition increases greatly, as many of your peers in CS50 will have never had coding experience, but mostly everyone taking CS51 is somebody who succeeded in CS50.
Don't take this course expecting something similar to CS50.
Anyone with any sort of interest in CS should take this course. Functional programming and OCaml are beautiful, and there's a certain aesthetic appeal you get from writing code in this course you don't get in CS50. The final project is a lot of fun if you put work in, and you come out of CS51 amazed at what you can do after just one semester (I implemented a facial recognition algorithm that detects whether the webcam is seeing a face or not... how cool is that??). Great course, would definitely recommend.
The psets are a lot of work, but also quite fun! I did not take CS50, but managed to get by (though the midterm was definitely difficult). Section notes are very useful, perhaps more useful than lecture!
This class is EXTREMELY difficult for those who came in with CS50 as their ONLY background for cs. Be prepared to spend hours upon hours on psets. I will say though that I learned A LOT, and it is worth taking if you're schedule can accomodate the extra hours of work.
One of those rare introductory courses that does not underestimate its students. Most of the learning happens in the context of homework and final project, which will take more time you would normally assume. Also be prepared to do a serious amount of independent research on algorithms and methods for the final project, but the course staff will prove very helpful. I took this class without having taken CS50 and it can surely be done if you have programming experience. While not easy and kind of technical sometimes, the class is definitely worth it. You will actually learn to write efficient, elegant, scalable code.
I learned so much in this class. It is a lot of work but it really can be rewarding to complete every week. It's taught very well and I felt like I got a lot out of the class.
This class is incredible. If you loved your super cool CS50 final project website, not necessarily the best course for you. If you think algorithms and abstractions are cool, definitely the class for you. The key to success in this class is time management! The problem sets are mostly broken into small, easily managed steps. However, you'll get screwed if you don't plan ahead and get stuck. The midterm was difficult but not time-pressured, Morisett is fantastic, and lecture can be dry but is overall interesting if you pay attention for the entirety of the lecture.
This class is great for learning about how to program well, as opposed to merely "throwing shit at the screen" as Professor Morrisett likes to say.   The lectures are engaging.   The two major programming assignments, Moogle and OMG Cows were very time consuming, as was the final project.   As long as you account for that time and start things early, however, the course is very doable.
CS50 will NOT teach you how the be a great programmer, that is what CS51 is for. Even if you aren't thinking to concentrate or secondary in CS, I strongly recommend this class because it shows you how to reason about good code. You learn all about good, proven coding practices and you will be hirable as a programmer after this class.
Think carefully before taking this class. It is a lot of time commitment: problem sets can be brutally time-intensive, difficult to get help on (go to Office Hours definitely) and there's a lot (especially in the beginning, syntax) to go over. Consider what you want to get out of it (think about why you want to learn Ocaml and functional programming in general; they can be good things to learn but think about why you want to learn it).
Reasonable introduction to functional programming.The treatment of object oriented programming is somewhat cursory.
If you want to learn how to think, not just just about computer science, but problems in general, take this class. It's a lot of work but it is incredibly rewarding, and it makes your smarter.
CS51 is a computer science class for computer science-minded people.  Though the language used (OCaml) is not one you're likely to see again, it's very helpful for teaching the concepts of the class, which you will use again and again.  Both the problem sets and final project are quite rewarding.  Compared to CS50, much less time is devoted to debugging code, and much more time to design and understanding.  Overall this is a fantastic course that I highly recommend.
This class is way better than CS50. In CS51 you will actually learn computer science skills that would be useful in a workplace environment. With that said, the CS department will eat up your week nights like you belong in a dark, cold box with the executives laughing it up in the penthouse sweet.
Take CS50 seriously!
Make sure you understood CS50. Make sure you like computer science and not just the atmosphere and free food that CS50 gives off. You actually have to think in this course, you can't just go to office hours and ask the tf to walk you through the pset. If you try to do that, you will be in for a rude awakening.
The material is awesome (though OCaml is kind of useless), and the class was solid overall. Professor Morrisett can be a bit pretentious, but he's a good lecturer so deal with it. Much harder than 50, though, so be sure you're comfortable thinking programmatically.
Start psets early. Although Morrisett makes a big deal about it, you don't have to go to lecture. His lectures are interesting surely, but it's easy to get lost if you're new to this whole computer science thing like me. He often (towards the first half of the course) failed to explain things fundamentally enough for me to understand them in real time, hence re-watching lectures online turned into only watching the lectures online.
Great class! Overall it teaches you how to program well and teaches you a different kind of programming which is functional programming. It is not an easy class, but still doable if you start your psets early (before the last day its due). You will learn how to test your code and make sure that what you're doing is right.
TAKE THIS CLASS. This is an amazing class that will teach what CS really is. Although CS50 helps in creating enthusiasm around CS, CS51 is going to show you how beautiful and at the same time hard, programming is. Greg is an excellent lecturer and you should attend all lectures. It's of course a lot of work but totally worth it.
This class will break you down and build you up.
CS51 is a good deal more difficult than CS50, and compared to CS50, CS51 doesn't have that "cool" appeal either.  Morrisett is a good teacher, though, and the TFs are all good too.  Make as much effort to go to class as possible, because unlike CS50, lectures are generally really helpful for problem sets.  Problem sets are due on Fridays at 5pm which sucks because that means that your weekend doesn't start until then (or Sat at 5pm if you choose to take a late day -- you have two).  It's a bit frustrating how long psets take.  Essentially, if you don't get started by Tuesday, you have no chance to complete them.  The final group project checkpoints (which start in February) are annoying at times, but helpful for keeping on track with the project.  Make sure to find a good group.
Excellent course - teaches you to think differently.
CS51 is real computer science at it's finest. It is fun, informative, and challenging.
This class is great!
Very useful for technical interviews and deeper CS logic.
This course is a great introduction to both functional and object oriented programming. It leaves you with ten times the CS background you get from cs50. That said it's hard and a lot of work. It'll be your life.
Take CS61 instead. You will live a longer, better, happier life.  No but seriously, this class has absolutely no regard for the fact that you as a busy Harvard student with other classes, extracurriculars, jobs, and commitments. Additionally, CS50 is not really adequate preparation for this course - you will be much better off if you have CS50 and CS61 under your belt before undertaking the task that is CS51.  On another note, whether you find it relevant or not, Prof. Morrisett takes pride in being incredibly caustic and condescending in his everyday speech and lectures. If you're a sensitive individual, tread lightly...
It's great!  CS50 did an excellent job of getting me interested in computer science, but I think I enjoyed this class more because I found the language (Ocaml) much more intuitive than C, the material in general seemed more organized, and the exams were much more reasonable and less random.
The problem sets are usually manageable with <10 hours/week. Just don't expect any feedback on your work - the course staff is too busy to tell you what you're doing wrong. Don't expect partial credit on exams - they're also too busy to actually read your reasoning.
On the bright side, you learn some good programming paradigms in this class. The class will attempt to teach you how to program efficiently, cleanly, and smartly. Most of it's somewhat common-sense (e.g. factor out repetitive code), but it helps to have people hammer it into your head. I'm impressed by the dedication of the TF staff, though to be frank I didn't get much attention because there are just so many people asking about so many bugs at every office hours. CS lectures are hard to do well, and I thought Professor Morrisett did a pretty good job. He tries to make it engaging and interesting, and I did feel that I learned a good deal from them, though the combination of constant Q&A and inessential demonstrations led me to devote less than my full attention. The problem sets are OK, but very cookie cutter, and feature very little room (in fact, I'd say none) for making your own design or algorithm choices, which means that they are both less interesting and involve a lot more drone-work. // My final complaint is that I thought the tests were pretty poorly written, in the number of errors and the choice of material.
THIS IS NOT CS50. The lectures are incredibly boring, the assignments are syntax and testing oriented and poorly organized. Greg's a good guy, but he's got his own agenda in terms of what he likes about computer programming, and overwhelmingly detail and syntax oriented. Definitely don't take this class if you want to do something other than software engineering for a career.
Somewhat harder than CS50.  OCaml is an interesting language, and it takes time to grasp the syntax of the language. Go to both class and section.
Take it if you want to do CS or need to for engineering, but be aware that the teacher isn't interested in being nice and the problem sets can be ridiculously time consuming. Do yourself a favor and look up OCaml (or whatever the language they expect you to use in the future) during winter break and try to learn at least a little bit of syntax, it will make your life easier. Get good project partners early.
This is much harder--but also more intellectually stimulating, and not necessarily as a result of being harder--than CS50.
THIS IS HARDER THAN CS50.  At least as hard.  At least as much work and more challenging conceptually.  By that I mean you're not dealing with if statements and for loops, like in CS50, but rather complex data structures, parallelism, modularization, and event handling.  If you did not understand recursion before taking this course, you will have a deep understanding of it afterward.  Plan on spending a lot of time on the psets.  The class ends with both a final and a final project.  One of the hardest classes I've taken.
I recommend CS51 with major enthusiasm. It's probably the most rewarding course I've taken at Harvard so far. The information and practical CS skills you leave with (abstraction! efficiency!) are completely worth the work. It's rather difficult, but never unfairly so, and extremely rewarding if you put in the time to grapple with the material in assignments. Don't put off problem sets until the last day or so, because while you might be able to piece together decent solutions, you won't absorb the material in a meaningful way. If you give this class the requisite amount of time, expect to love it. Professor Morrisett is an engaging and super-knowledgeable professor who loves his subject. Take this class if you love CS, or if you want to find out if you actually love CS. While CS50 gave me a taste for CS, it was 51 that made me really appreciate the discipline.
Functional Programming is awesome!  I liked CS 50.  This was waaaaaaaay better than 50.
This is a great class. Greg is an excellent and enthusiastic teacher. Watch out for the grading though. The TA's will make errors that cost you serious points, so you have to be constantly vigilant.
OCaml is a very elegant language with questionable usefulness. I don't think the class is necessary for people who don't plan to take more CS classes later.
AAAGH I LOVE THIS COURSE!! <3 OCAML <3 MORRISETT. he's so good at teaching. i put a lot of time into the p-sets but got a lot out.
great class!  The problem sets are really fun and you don't have to go to lectures as long as you study the powerpoint presentations.
This course is extremely difficult, but you will learn a lot. If you are a CS concentrator, definitely take it!
In this class you will truly learn to program
Taking this class will let you know whether you want to do CS. It's great!
If you're interested in Computer Science, then this course is fantastic. CS 50 is great for people who aren't interested as much in studying CS, but want to take a course in it. CS 51 is an awesome course for those who are genuinely interested in the field of CS itself.
You will become a much better programmer, but the course will require a lot of time from you.
Personally, I really enjoyed CS51 -- but whoever said this class is easier in some ways than CS50 was either a huge boss or a troll. The class is in every way more difficult than CS50; it is a huge time commitment and quite difficult, especially during the late nights of psetting. That being said, Morrissett is a great teacher and I am incredibly glad I took the class, but be prepared to be shaken from the "bells and whistles" mentality of CS50. It's definitely conceptually more difficult as well.
Class is difficult and abstract, like no other CS course you've taken before. That said, if you're willing to put in the work you will become a pro at abstraction and pure functional programming. It's what you make out of it.
This class was so much fun! I did not take CS50 but took AP CS in high school and it was completely fine. The class is self-contained so as long as you pay attention to lecture and put the time into the psets, you will do great. The professor is awesome. People tend to skip lecture a lot because it is video-taped but I personally went to every single lecture because I found the professor very entertaining. The book is helpful to read along but it is not absolutely necessary if you don't have the time to sit down and read the chapters. The project at the end is not as much work as it seems, because you have a group of other people to work with, it is really doable. Section is really helpful, go to every one of them!
This course is really enjoyable and should be taken by a CS concentrator or secondary.  Greg is marvelous and the problem sets are interesting.  Functional programming is a really useful paradigm even if used as a guiding principle in other styles.
This class is not difficult, but problem sets will take a very long time. The final project may also be difficult if not planned out properly.
This course made me such a better programmer. It really reinforced important concepts that every programmer should know, especially because I didn't have any background before CS50. It teaches you A LOT, and Greg is an amazing lecturer and wonderful guy all around. I find myself applying what I learned here to so many difference aspects of coding, even if I'm doing web-dev with PHP or something. It's a really good course. It's definitely tough and challenging, and I've seen way too many sunrises throughout the semester because of it, but it was worth it.
Despite its challenges, tough problem sets, and exams, CS51 is one computer science course that you will definitely not regret taking. It lifts and polishes your thinking of computer science problems so that you leave the course a much better computer scientist. The problem sets are in OCaml, and while this isn't a very useful language in the every day world, Professor Morrisett has chosen an excellent language to convey the ideas and skills his wishes to teach his students. I highly recommend this course for anyone who is even remotely interested in computer science or wishes to think and write like a true computer scientist. Oh, and Professor Morrisett is incredible.
Just make sure to stay on top of the material and have fun with the problem sets! Instead of trying to memorize all the nit-picky details, try to get an overall understanding for the logic/reasoning.
Ehh... Mixed feelings about this course.  Greg is an amazing instructor, but only take this course if you're into the whole abstract part of programming.
Take this course if you are really, seriously interested in programming or enjoy problem solving. Do not take this as a fun continuation of CS50 because you will find out on the first day that this, indeed, is not CS50. This class will take you into the depths of the ocean of Recursion, teach you about functors, modules, functions that take in functions, parallel programming, concurrency, locking, Big-O of space and time, and binary search trees. If that excites you, by all means take this class. But know that it can be unforgiving, that you will be challenged to an extent you never knew you had, that you will be stressed, that you will go through all this in the name of "wanting to be a good programmer." This can be a bitter experience and if you are one of those people who worry about their grades too much, just keep that in mind.
If you just took CS50, enjoyed it, and are looking for another CS class, think very seriously before picking this class. The support system and fun culture that everyone loves in CS50 is nowhere to be found in this class. In CS50, I had to put in a lot of hours, but still got an A without too much struggle. In this class, I pulled multiple allnighters to finish problem sets, and still ended up failing those problems sets.
its a lot of work, but if you put in time to make your psets really good and if you really try hard to understand the material before starting your psets (but definitely start >3 days ahead) then you'll do very well on psets AND you will find the exams quite easy. Prof Morrisett is wonderful.
Take it. Greg is awesome, and the material covered in class will really make you think. You'll realize there's more to CS than the code itself. This class is all about elegance in thought first, and then in your code. You'll emerge with a clearer and cleaner approach to problem solving.
If you just took CS50 and were intrigued by the topics of CS and are considering a secondary or a concentration, definitely take this course to see if CS is right for you. This course is definitely not a cakewalk and you'll have to put the time in to get something from it, but I recommend it to anyone who's on the fence about CS.
... so I'm weird, but I liked to start psets a week early not because I was diligent, but because they were fun.
This class can be run better. Yes. But this class has taught me SO MUCH over the course of a semester that none of that matters. You come out a completely transformed programmer and thinker. It was the hardest class I took this semester, but it was all worth it. Be warned -- problem sets are a pain sometimes.
If you want to do more programming at Harvard, take CS51.
Course materials are great, and functional programming is really, really interesting. Doesn't require too much work. Problem sets can be tedious.
CS51 is a great course, it provides you with a solid understanding of how abstraction works in the grand scheme of functional programming.  While the language the course is taught in is not really that applicable outside of class you will come to love it over the course of the semester because:  (1) it puts all students on the same semi-level playing field at the start of the course, (2) it forces you to understand the material from a theoretical sense so you can readily apply what you learn to other languages, and (3) the "type" system in OCaml really forces you to understand what is going on with your code (and gives you a good way to figure out what is wrong if you don't).
Awesome class. Really cool materials, and the staff are great. Please don't just stop after 50!
While perhaps not as time-consuming as CS50, 51 definitely requires you to think harder about your code. That being said, the rewards are immediately evident - while you might not come away with a ton of practical knowledge, you'll be a much better programmer and the skills you learn will spill over to any future CS-related endeavor that you choose to undertake.
Can be hard if you don't "get" programming and logic
This course will help you to become a better and more thoughtful programmer.
Ocaml is actually the best thing ever.
Not as hard as everyone says and totally worth it. Not easy, though.
This class was very refreshingly realistic after all the bells and whistles of cs50. Functional programming is useful once you get the hang of it, and the psets are not *as* time-consuming as many of the CS50 psets. Morrisett is a fantastic lecturer, and the tests are very doable. Make sure you pace yourself on the final project. Overall, a good course, though (like all CS courses) a fairly time-consuming one.
This class is great for teaching you how to be a better programmer and improving your reasoning skills when writing code. Although OCaml is not a commonly used language, I actually really liked it after coding with it for a while in this class. The psets normally take a long time. Some of them were interesting while others were sometimes tedious. One aspect of the class I really liked was the team project. If you can get together a group that's really excited about an idea, then you could develop something that's really cool and practical. Overall, I'm very glad I took this class because it taught me many concepts and things that definitely made me a better programmer.
Be ready for a CS class that is time-intensive, challenging, and often frustrating.  Say goodbye to your Thursday nights (and perhaps, your predetermined notions of being a CS-concentrator!)
Functional programming is definitely an important concept for modern computer scientists to be familiar with. It's fun, not terribly time consuming, and it makes you think differently about the flow of programming.
Learning functional programming is extremely helpful to developing strategies and improving ones mindset for constructing solid code.
Be very cautious about your choice of final project. It may kill you.
You learn a lot of really great programming topics, such as functional programming, object-oriented programming, and concurrency. This is a difficult course, but essential in the curriculum of a computer scientist.
The topic is SO INTERESTING. Function language is awesome! This is what salvages the course. Otherwise the course would be a disaster with staff that just can't stay organized or care about the course to do logistics correctly. For such a large class that has been going on for many years, I was surprised at how disorganized the psets were. Grading takes forever, and you get almost no feedback. Poor structure, but good content.
If you're considering taking this class and CS124 simultaneously, think very carefully. In fact, don't even take CS51. Everything you learn in CS124 is more applicable, better thought out, and more interesting than CS51. Maybe they'll revise this class for next year, but given that they've had years of experimentation and still managed to botch two problem sets such that the teaching staff themselves recognize that it's a mistake, I wouldn't get too excited.
CS51 is a challenging class. Morrisett kept his promise of turning our world upside down with Ocaml but it helped me see past the syntax and gain a deeper understanding of best practices in programming. Assignments don't take hours because you have to write a lot of code; you spend most of your time thinking and end up writing just a few lines of code.
Seemed like mostly a solid course - I feel like though people didn't really get into the course and it was a bit lackluster, perhaps.
You learn a lot of extremely useful programming concepts like abstraction and object-oriented programming.  After taking this course, I feel much more comfortable approaching programming projects on my own.  It's a very useful and generally well-organized class.
It's a great introduction to functional programming (if you've not had experience with that before), and the final project is pretty involved and interesting. The psets are a good way to learn the material.
Its very different from CS50, with much more focus on learning to program well and efficiently. Definitely interesting for more math-focused people.
Prior to walking into this class, I was a terrible computer programmer. I wrote lines and lines of sloppy code that just happened to compile. Now, I can say that I'm infinitely better. This is a hard class and requires a lot of time. However, you need to take it. Trust me, you'll walk out with a much greater understanding of writing good code than you ever thought was possible.
Great class. Apart from the material being incredibly important for those wanting to pursue CS further, the lectures were interesting (and they're videotaped!) and the assignments were challenging but rewarding. There's also a great support system in place, though they don't coddle you as much as in CS50. Overall it's a very manageable class; I learned a lot and it stretched my thinking in new ways without killing me!
CS51 is difficult, but doable! You get what you put in!
Expect to work hard on problem sets, but most can be finished in a night or two.  Make sure to read through the spec/section notes/lecture notes before hand to get an idea of what will be required in the assignment.  Start the final project early, and there are checkpoints to make sure you stay on task.  Be sure to focus on the overall design of the project, not just the algorithm implementation.
Be willing to work hard and you'll learn a lot. This is a way to "zoom out" from something like CS50. There are some kinks that they'll keep trying to work out (i.e. problem sets that are unintentionally too difficult), but overall it's a great course and worth the effort. Section was excellent - definitely go!
This class is more difficult and time-consuming than CS50. It is a great class and at the end you feel like you learned important material, but the process is difficult and sometimes frustrating.
start psets early
If you liked the data structures part of CS50, and want to learn more abstraction, data structures, modules, and object-oriented programming, take this class! It can be a lot of time, but you'll definitely come out of the class a competent programmer.
Seriously consider that this class takes a lot of time. Difficult p-sets (which are much harder than CS50) but take just as long, if not longer. A group project due during reading period (while you still have other p-sets to do) along with a midterm and final. You will constantly be working for this class and your social life/ happiness will suffer if you're taking other difficult classes. The professor is awesome and you will learn a ton of useful info about good coding practice, BUT these are some things to consider before you take the class.
This class is way more interesting then CS50. The class isn't very difficult in terms of the material, but the problem sets take a very long time. Be prepared to spend a few days working on them.
Take this class if you like a cool quantitative class.
Pick people who respond to email for partners when doing the final project.
This class is a great sequel to CS50. It continues to develop your foundation as a programmer. You might never code in OCaml again but the concepts it teaches are extremely useful in learning other languages. I am currently learning C# and making the connections to OCaml is really speeding the process. The class also teaches you general techniques on how to approach and solve general problems in computer science. extremely useful if you plan to continue in the field.
It's a good course if you have a good tf. And be prepared to spend all of your time on this course.
It's WAY better than CS 50, that is, if what you're looking for is real computer science and actually valuable material as opposed to a programming course. In 6 months you won't remember how to define a struct in C but you will remember the principles of programming you learn in CS 51.
A great class. Hard but really good. And it teaches you how to write good, short, concise code which looks beautiful and runs well.
This class is very time consuming and very hard, but very rewarding
It's not just "the next class after CS 50." This course teaches you how to program well, and it'll push and grind you into a better programmer and computer scientist. Beware of deadlines - do not procrastinate.
Very challenging but very rewarding.
If you're at all interested in a secondary or concentration in CS - take this course. Morrissett is awesome; try to get to know him better. Be prepared to put in ~12-18 hours into a pset (so start relatively early). Keep up with the lecture material (there's a close tie between psets/exams and lecture material). Section is optional - I didn't find it very helpful (usually just a regurgitation of lecture material) but having a TF as a go-to resource may be a good incentive to attend.
This class is a fun way to learn about abstraction and functional programming in general. OCaml is a more interesting language than C. Problem sets aren't that hard, especially if you look at them earlier than the night before.
It covers a lot of material, and some of it may be interesting to you, and some of it may not be. Even though Prof. Morisett is extremely knowledgeable, lectures can be a bit scattered/run on tangents.
The class is more conceptual than CS50, so that what you learn fits under a more unified paradigm (which depending on your preferred learning style, might make the class easier to comprehend). You should start psets earlier (as usual, it's harder to code under stress). Professor Morrisett is an awesome awesome lecturer and has a strange fascination with cows. Moo!
Be ready to work hard.  You feel a sense of accomplishment once you get through this course.
This course is good for learning how to refine your programming skills.
Its difficult but rewarding.
You'll learn a whole new side of CS.
The class is difficult, but the reward for correctly learning the material is great.
Take it with a grain of salt. The Psets won't be fun, but otherwise it's interesting.
This is a time consuming course. Problem sets will take a long time. Nevertheless, everything in the course is doable. There are enough resources to complete every assignment and to help you learn any difficult material. I would highly recommend this class to anyone who enjoyed CS50 and wants to continue exploring computer science. However it is also important to note this is not CS50. I found CS50 to be a over-glamorized presentation of what CS is. And although I enjoyed that course, I enjoyed CS51 more because it felt like it was presenting more of the challenges and methodology that actual computer scientists face and use.
This class is great, but it is not easy in the slightest. The PSETS are deceptively long, so you shouldn't assume that because this is an intro course that the commitment will be low.
Be prepared to do a lot of work, but also to learn a lot about computer science and the direction in which modern technology is heading.
Cows!!!
Definitely take it! Greg Morrisett is a wonderful lecturer, and you'll learn a lot. The psets take a lot of time, but what else do you expect from a CS course?
This class can be really hard, but only if you make it like that.  I didn't start problem sets until the night before they were due, rarely went to class, and rarely went to section.  If you do the opposite of these, or just start the problem sets earlier and go to lecture fairly regularly, it will be a lot easier for you. Also, even though Morrisett may kind of seem like a dick at first in lecture, he's actually a nice guy to talk to. Ocaml's pretty cool; projects aren't. You should probably take the class.
Allocate a lot of time for the assignments. Plan your projects responsibly. The tests are cake.
I highly recommend this course to anyone with a programming background. I did not take CS50, and in fact this was my first CS class of any sort ever, however I've been a hobby programmer for a number of years, mostly using Python. I found that background to be more than sufficient to do well in the class. And I learned SO MUCH! I may have been able to write code before, but now I write GOOD code. I didn't even really know the difference before, but it is really important. So take this class. Write good code. OK?
This was a great class to take and it really helped me solidify my enjoyment of computer science.
If you are uncertain of whether to do CS as a concentration, take this. Many people think that they love CS just because they took CS50. But let me tell you: CS50 is not computer science. The materials introduced in CS50 is at best elementary and if you enjoyed it, it may partly be because it is so easy and extensive help is available. But CS51 is more like the real-world computer science you are going to face. Problems are not always as interesting and demand much more problem solving skills that what you need in CS50.Take CS51 to get a real taste of CS.
Great follow up to 50. You will learn to be a better coder (or at least to think about your code). Functional programming is amazing and definitely worth knowing about. Take this course if you want to take your coding up a notch (good for CS majors and non-CS majors alike, but not as hold-your-hand as 50).
Best class I've ever taken. Has taught me everything I know about coding. Material is the best I've encountered. Real world lessons, design principles, software engineering practices, functional programming. Morrisett is a boss. This is not CS50.
take the class
This class is very different from CS50. You should take CS51 only if you're serious about computer science--it's not sexy, and it's not stuff that has tons of direct real-world applications. If you're going to take this class, be prepared to think abstractly and recursively. With all that said, Ocaml is a cool programming language, and this class can be pretty mind-blowing at times.
Professor Morrisett is a great guy, and though the course may seem difficult at times, it is actually really fun and enjoyable with the exception of the final project (but that is my personal preference).
Start the problem sets earlythe difficulty varies widely. Just because one is easy doen't mean the next one won't beat you up. The following week's may again be easyyou just have to look closely at the writeup and start coding as early as possible.
Brace yourself.
CS51 is both more enjoyable and more interesting as a CS class than CS50. The problem sets will hopefully become less ambiguous and buggy (especially the last one on object-oriented programming) over time, and the final project will probably be revised according to student feedback.
CS51 is not CS50, but it will give the wonderful foundation that CS50 provided a lot more heft. Definitely take it.
While this course can be frustrating and the lectures uninformative, the subject material and psets are excellent. I ended up using this course like a directed self-study.
Good course to take, pretty useful techniques in recursion.
Be prepared to spend a lot of time on this course. Attend office hours. And be prepared to learn a lot about where programming is going in the future. Extremely useful. Functional programming is fascinating.
Take this class! It's much harder than CS50 though, in the sense that you have to be able to think a lot harder. Less just making cool stuff (though there is still some of that!), more thinking about problems interestingly.
This class was really hard. It was harder than any classes I have ever taken in my life. Do prepare for a hard semester if you take.Also if you are not a cs major, I would not recommend you to take his class.
This class is great, and you learn a ton, but one must start the psets early, and seek out ways of getting help outside of office hours. OH are a mess and they are usually not sufficient in helping everyone who needs help. Beyond that, functional programming is a very useful subject to know as a programmer. Would recommend for concentrators, not for secondaries (just take CS61)
It is a lo of work but totally worth it.
Like most CS courses, a lot of outside self-teaching is required. Make sure you know how to figure out new material that is not necessarily included in lecture.
This is a great class to take after CS50. It is a lot of work and you will spend a lot of time on it, but it teaches you not only about functional programming (and smart programming in general), but also how to work as part of a team.
This course is NOT ANYTHING LIKE CS50. I thought that was fantastic, but you might not. Let me explain. CS50 is about programming: learning to write code and put together website. Throwing lines of code at the compiler until things work. CS51 is about COMPUTER SCIENCE: thinking about code abstractly, making your code safer (from other programmers who might use it and from your future self), and most importantly, learning to write code that isn't terrible. For me, CS51 was my favorite class this year because it really changed the way I think about programming I think about design when I program and I try to write code that doesn't just work, but it works WELL and is BEAUTIFUL. CS50 is about making cool programs that do interesting things (games, websites) and learning just enough stuff to make something cool. But CS51 is about learning ideas and concepts and turning those into programming assignment (symbolic differentiator, web crawler) that are cool from a computer science perspective, but aren't "fun" things to show off to your roommate like in CS50. I found it fascinating and challenging in a way that I never felt in CS50, but you might not. If you want to learn about COMPUTER SCIENCE (not just how to write code that runs), you will enjoy the course. I sincerely hope that the teacher next year is as knowledgable and thoughtful as Morrisett!
I came into this class with significant experience in computer science, but with little in functional programming. I expected CS51 to be a low time commitment, but a good fifth class to learn about functional languages. However, while I did enjoy the first few problem sets, the later ones no longer focused on functional languages, but more on standard programming techniques like OOP, abstraction, etc. with which I was already familiar. The problem sets became boring and I was no longer getting much out of the class. If you have experience but want to learn functional languages, I would recommend a course like CS152 instead.
This class is great! Greg is a fantastic professor and it definitely teaches you about programming from a completely different perspective.
This class is taught very poorly and the workload is unreasonable. Most of the stuff that the professor taught in lectures could easily be learned by reading powerpoint slides and were unhelpful for the problem sets.
Start your pset as soon as it is released. Sometimes, you will need a full week to complete it.
This class is difficult, but you can certainly succeed if you put in enough time. I think I probably worked about 15-20 hours per week on the psets, and I feel like I did very well in the class. You learn a lot of useful programming skills in this class, including how to write clean code and how to wield the power of abstraction. OCaml was interesting to learn about, even though it's off the beaten path in terms of programming languages. OCaml is still very useful to learn about and many of the skills you develop from learning OCaml will transfer easily into other languages (especially recursion!). I believe Greg is teaching this class for the last time this semester, so I'm not sure how the class will change in the future. Thus, caution should be used in drawing too many conclusions from this review or other reviews from this semester.
Really hard class but teaches you a lot about programming as a whole, since you focus on functional programming.
take it!
So much more fun than CS50. The psets are awesome. Final project is a little dicey if you're not big on group work (which I'm not), but that's part of the point - most coding in the real world is done in groups, which carries unique challenges. Problem is that the course doesn't provide you any recourse if a group member isn't pulling their weight, so make sure to work with a group you trust, hash out all responsibilities early and keep track that everyone is doing their share.
It's more fun than CS50, honestly. The psets are more like brainteasers and less like a step-by-step guide that just tells you what to do with little thinking involved. Like all CS classes, it can be annoying at times, though, and it does take up a lot of time.
Be prepared to do nothing but work for a while
It depends on how well you understand CS. If computer logic is difficult for you, this will help sure it up. If it's intuitive, it's not terribly helpful.
Take this course if you have lots of time, and be prepared for studying a lot. It gives you a specific set of skills, but does force you to practice coding.
This course is incredibly difficult. What you learn is difficult to apply anywhere. You learn a language not used but spend a lot of time learning it. Psets are incredibly hard and unless you have a friend who is amazing they will make you miserable.
It is a difficult class, and you will have to work a lot if you want to do well on the problem sets. The midterm was killer, and the final looks like it will be more of the same. That being said, it is a very good class and I felt like I actually learned a lot about coding and how to think in a different way. Despite the workload, it is a great course and worth taking as long as you are willing to put in the requisite work.
It was hard, but I learned a lot and it was much better than CS50.
I actually enjoyed this class more than CS50, I really liked going in depth with functional and object-oriented programming.  You'll probably never use OCaml outside of this class, but you'll gain a greater appreciation for functional programming and recursion after taking it.
CS51 is a much more accurate representation of what actual CS is like than CS50. No more handholding and fun and games; CS51 is hard work. However that said, the material itself is extremely fascinating and you will become a much better programmer from taking this course. Go to office hours and be prepared to surrender your life to CS51. This will probably be my lowest grade this semester, but I still wholeheartedly recommend the class because the material is that interesting.
This course is very demanding in that problem sets are based on material learned in class, but significant time is required to fully understand and comprehend the material.
I personally like functional programming a lot better than imperative programming, so even though I was told that OCaml isn't very widely used, I enjoyed learning the language (and learning more about how to learn languages). Professor Morrisett is genuine and passionate, and I found that being forced to work in a group or two or four was actually much more enjoyable than working alone. Multiple heads are better than one when it comes to debugging! The lectures do tend to drag on a bit, though.
Devote as much as time and effort as you can to this course in order for you to understand everything. Go to office hours.
This class changed how I think about computer science and problem solving in general. It was extremely fascinating and just a lot of fun.
I thought this was a great class, but next year y'all will have a different professor, so what I say doesn't really matter. If it's structured the same way, I think it's a must-take, especially for CS concentrators. You'll learn a lot.
If you have taken and done moderately well in CS61, or even found CS50 to be easy, it's not really worth taking this course. Learn functional programming on your own time and take a class where you'll learn something more useful and specific.
Absolutely necessary if you want to do anything legit in CS. Don't start problem sets late. Marcus is a great TF.
CS51 is a great class for learning the basics of a wide variety of fields of computer science, such as functional programming, OOP, algorithms, etc. We use OCaml in the class, which causes quite a few students to drop out at the beginning, but this becomes relatively painless after about 3 weeks.
This class was pretty great although it made me realize that CS is not my thing.
This course is fantastic.  Yes, the problem sets are hard, there is no doubt about that.  But if you're considering this class you probably survived CS50 and are coming back for more, so you know what you're getting into.  Although the problem sets are hard, there is an incredible support system in the form of the TFs, who will help you break down topics from lecture during section as well as conceptually guide you through the problem sets during office hours.  It's said that Allison and Ben are graduating, since they were absolutely fantastic head TFs.  For example, Office hours usually go from 8-12 the night before the problem sets are due, yet Allison stayed an extra TWO hours to help my group finish our problem set.  That sort of commitment from the teaching staff is unparalleled.  Once you finish the problem sets, looking back at what you accomplished is incredibly satisfying.  Who else can say that they made a miniature search engine called "Moogle"?  Plus, while CS50's style is to give you the basic structure and filling in the blanks, CS51's psets often force you to start from scratch, which in the long run is incredibly more conducive to truly understanding programming.  Lectures are recorded, so you can skip them, but Greg is a pretty good lecturer and an incredibly nice and funny guy, so you wouldn't want to.  Unfortunately he's also leaving (curse you Cornell!), so the course definitely won't be the same without him.  Final project can be pretty challenging depending on how ambitious you want to be, so definitely keep a reliable plan B in the back of your mind when working with your group.  Lastly, the exams are reasonably challenging, but if you take the time to learn the concepts in lecture and section notes, they should not give you too much trouble.  Overall, I cannot recommend this course enough.  This was not CS50, and that's what makes it awesome.
Very difficult and didn't find it useful at all because Ocaml is not useful.
This is a great class that will teach you a great deal about computer science. You will learn how to code better and learn about computer science concepts in general. The problem sets and final project are fun and are a great way to learn. Professor Morrisett is a cool guy!
Please try to have some prior knowledge of functional programming before entering this class or else the beginning will be a bit rough. Furthermore, do not expect this to be like CS50, it is much more advanced. And also to those who have had countless programming experiences but have had no functional programming experience, DO NOT EXPECT THIS TO BE A WALK IN THE PARK. You will be in for an unpleasant surprise. You have been warned. With that being said, the class teaches you a lot and I would like to believe I have learned a lot.
This class really helps you think about programming in a way that's different from what you've been taught before and it's a good segue into further CS classes, it seems.
Well structured course that explores the basics of computer science. Much more of a thinking class than CS50.
It's hard but worth it
It's a fun class, and easy if you've done work in computer science in the past. OCaml occasionally sucks, but I understand its value as a teaching tool. That said, I will never willingly use OCaml again, particularly when other and more beautiful functional programming languages exist.
Take this class if you want to improve your programming skills.  You'll be a better programmer after this class.
For background info, I am a freshman who took CS50 in the fall and had little prior coding experience. I found this course to be one of the most time-consuming courses I've ever taken, but also one of the most rewarding. I was really torn about whether or not to enroll because CS50 psets gave me low-key anxiety last semester, but I figured that fear of a challenge was a stupid reason not to take the class- and I'm really glad I did! Yes, there were some very late nights, but CS51 creates bonds between people like no other and I met a lot of cool folks at office hours. My only regret with the course is that it definitely became my priority of the semester, which took time away from other classes and activities I loved. But to all my homies who are hesitant to make the leap because of tough psets and a stressful class- it's manageable and you can do it! Just be sure that this is how you want to spend a significant amount of your semester.
This is the best class I have taken at Harvard so far. Professor Morrisett is an awesome lecturer who presents the class with a lot of material in CS. This class is not much like CS50. There is a lot less pomp and circumstance. Rather than watching random videos and listening to music during lecture, this class actually teaches during lecture, meaning that lecture is worth your time and that you have a lot less to learn on your own. Also, the tests are graded very harshly, so be sure to read the directions carefully and think clearly about your answers! Sections are also quite good, and provide good examples from class, which help to make the lecture topics sink in. Finally, there is no outside reading or anything for this class, meaning all the work outside class is actually coding.
It's ridiculously hard.
Great class with a great teacher
You cover so much material in CS51, but you really need to make sure to not fall behind in the class. The exams are graded really harshly.
Take it. It's a good one. Greg is a good lecturer. Your section TF can make or break the course. Study hard, pay attention the whole class not just right before exams, and don't let the language weird you out. It gets cool.
This class is very difficult but worth it. You will discover what it means to write truly elegant code.
This course basically teaches you how to do functional programming. Here "functional" means "everything is a function". In fact, for the first half of the semester, the programs you write are just functions (and tests for those functions). This was kind of annoying in a way, since you knew you did it right only if nothing was output! It's generally more interesting to me to write programs that output information on the screen/in a GUI.One of the more useful things you learn in this course is the concept of how to write unit tests, they're actually really useful and I've started using them in several of my other courses.One of the more annoying parts about this course was its use of OCaml. It's a very sparsely used language, which means that its documentation is pretty bad (unlike in C/C++/Java/Python/etc., in OCaml you have to spend a few hours searching around for how to do a very simple task). Additionally, I found the OCaml language very difficult to use; in particular, its use of parentheses was maddeningly inconsistent, and its lack of well-defined ends of functions, and inconsistent use of the double semicolon ;; were really confusing, and they detracted from the more elegant, functional aspects of the language. The compiler is also very annoying about making you write out every single case; in some cases this can be useful, but most often it's just annoying when you know that a particular case won't come up, but you have to code it in anyway.Finally, I was not overly fond of the fact that you are not allowed to use for and while loops, and the fact that you are always supposed to use lists rather than arrays. There was one assignment where, due to these rules, I had to write a 10-line recursive function that returns what in C code is one word: arr[i]! This situation occurred frequently.In summary, you will learn how to program without side effects, and prove that your code does what you want, but you have to be prepared to use a really awkward language in OCaml.
It is a very useful and enjoyable course. This course encourages students to apply in a unique way the concepts that they learn in class.
Be prepared to study hard.
The coursework in CS51 feels a lot more manageable than CS50. If you start the psets early you will be able to finish them without rushing to the last minute. However, like the majority of CS classes it still requires a lot of time, so you should plan out things early on.
This class is more abstraction than anything. Teaches you how to think differently, but not that useful in any way.
If you're into CS, take this course. It's a good introduction to many advanced computer science topics that you will see later on. You don't really have to go to lecture, they're taped, and you can do the psets in groups without watching them, but you need to know the lecture material for the exams. The exams are difficult, but not impossible. The psets are frustrating sometimes because they don't always relate well to what's discussed in lecture. Work in groups for the psets. The material is very interesting if you're into that stuff.
Whatever your qualms from CS50, CS51 is much better!  I really enjoyed this course.  The PSets were really interesting and manageable.
I would say it's a good foundational course in computer science but students should know it's very demanding and should be taken as your hardest course.
My friends told me about how CS51 was a wonderful class that changed their way of thinking and approaching CS problems. The class was great, but it should not have been my 5th class. I was taking 3 Stat classes and this course, and I must say that this class was more difficult than the other 3 classes combined. Taking this course is a huge time commitment for anyone.
It's hard if you don't have a CS background.  Make sure you have a smart friend who can help you with pset's if you take this class.
Definitely do it freshman spring if you're considering concentrating in CS, don't bother otherwise. It's a pretty standard CS course.
This course is good for people who are already interested in CS and want to learn more about functional and object-oriented programming. However, OCaml is not a very commonly used language, and I wish this course were based in another language instead.
The course covers perhaps three lectures of material stretched over the entire semester. As such, each problem set itself testes knowledge of very little material, yet the problem sets have been elongated so as to consume an unnecessarily large amount of time. To be sure, I regard the problem sets in this course as some of the least rewarding work I have ever had to do. The lectures themselves cover no material, as per CS50, and the use of OCaml in teaching Object Oriented Programming is laughable, particularly to those who have experience in, say, any other language with OOP components. The coverage of Analysis of Algorithms and Parallelism provides less understanding then a quick skim of their respective Wikipedia pages. Indeed, all that can be said of the class is that it did a reasonable job of teaching OCaml syntax - although the utility of knowing OCaml syntax is arbitrarily close to zero.
If you are at all interested in learning more CS after CS50 (especially if you are considering a concentration, etc. but only started CS in college), this course is very useful. This course allowed me to start thinking about computer science in a much more systematic and efficient manner. The material is organized well and concepts build off of each other. Problem sets are challenging, but once you complete them, you realize that you actually have a better understanding of the material from lecture. Morrisett is an excellent lecturer, providing the technical information as well as the more big picture motivations.
Great course - functional programming is fascinating to learn. It changes the way you think about coding, but it won't be easy.
This class was a lot of work, and became very difficult by the end, but it definitely helped me learn to think critically and logically.
A significantly different class than CS50, a lot more traditional for sure.
CS51 demands a more nuanced understanding of code and higher level abstractions than CS50, but meeting that challenge results in being able to see how the higher level abstractions connect to the code you read or write, and that is very rewarding.
If you're looking for the colorful and exciting lectures of CS50, don't take this class.  If you actually want to learn about programming and be given assignments testing you on material you actually learn, with help from the coolest TFs out there, definitely take this class.  Lectures were a little dull but that was a much better tradeoff from CS50 where there' s a lot of flashiness and not enough learning.  Morrisset is actually a pretty good lecturer and the tests were fair if you actually go to lecture.  The problem sets were also fair and there's a lot of help available.
CS51 was a relief for someone who took CS50 having never had CS experience before that. The class is very focused opposed to 50 and I felt like I was familiar with all of the class content that I needed to finish a pset. That being said the psets were very hard for me with a lot of them taking over 20 hours but this was made better by the awesome staff, Daven and Allison absolutely killed it and are a lot of fun to learn with and great teachers.
This was the second CS course I ever took. I wish I had taken more cs courses before taking this one.
This is a great CS course that causes you to think about programming in an entirely new way.
Disclaimer: I took this class senior spring because it was required by my concentration, and after having taken a lot of graduate math and cs theory classes.Having said this, I would recommend self-studying the concepts in this class instead of taking it. It was a good introduction to functional programming, OCaml, and some essential paradigms in modern programming (like parallelism and event), but I believe it'd be easier and faster for you to just pick that up on your own; the problem sets were a bit of a waste of time. I liked the final project though - it lets you implement pretty much anything CS-y you might want to know more about. But then again, you can do that on your own as well.
While this class is good in the sense that it teaches you the undoubtedly fundamental concepts of OOP and Functional Programming, it does so in a way that is not only boring, but is also very ineffective. The Problem Sets are very tedious, with basically thoughtless answers that don't incentivize learning of the content...
A good course to explore some of the more theoretical underpinnings of computer science
Although CS 51 is time consuming and taught in a seemingly useless language, the course is still highly useful. You learn a lot of useful skills that are sure to make you a better programmer in the future.
Learned some very useful things. It was a lot of work but also fun.
Much better than CS50 - take it if you're at all interested in CS/math. It's not as much about programming as a way of thought.
First of all, CS 51 is much better than CS 50. It's definitely a class, rather than a show with some problem sets to do on Wednesday/Thursday nights. It has meaningful lectures that are helpful and cover actual content. The material is interesting for many people who enjoy math/science. However, the problem sets are something to watch out for, as they're quite long and tedious. Take this class knowing that you'll have to spend a decent amount of time on it, regardless of your previous experience.
I liked this class more than CS50: it was less bells and whistles and more interesting problems. Lectures, particularly the early ones, were quite useful for the problem sets. You will want to start problem sets early, since they can get long and have conceptually difficult problems that will be easier to solve if you sleep on them. This class will teach you how to make your code better in style and more efficient.
If CS50 was the first CS class you ever took and you were disappointed by how gimmicky it was, please take this class. I didn't want to take it at first, but I am very glad that I did. It really made me realize how interesting CS could be and has made me want to take more CS.
It's useful, but do the work week by week to fully gain an understanding
Do it for the cows. Do it for 42. Do it for the Caml.
CS51 is a great course that I would definitely recommend taking. At times, it can seem kind of arbitrary that we program in OCaml, but overall the class does a great job of communicating the relevance of OCaml's style to writing solid code in any language. As a person pursuing CS as a secondary and not as a concentration, this was a great class to take to give me a better working knowledge of CS that I didn't feel like I got with CS50. That said, be prepared to have some agonizing times with OCaml syntax! Lectures were always very clear and helpful, though.
CS51 is a great way to expand your knowledge of programming. I found the material really cool and different than everything I've been exposed to with respect to programming so far.
This class is a lot of work. It is not CS50, and it is not a walk in the park. That being said, there's a lot of good material in this class and OCaml is actually a lot of fun - just be prepared to work long and hard for it.
This is a great class if you want to become a better programmer. It isn't a class for someone who doesn't want that since many of the skills will only be useful for professional coding.
This class was really intellectually interesting. The problem sets were manageable until the end, when they got a lot longer. Definitely start your problem sets early. Office hours and Piazza are frustrating and kind of useless, so try to make friends who can just help you. Get a good partner and don't be afraid do dump your partner if they suck. Exams were tricky but fair.
Take this class if Professor Morrisett is teaching it. The course is somewhat disorganized and understaffed, but it is an interesting, rigorous, and engaging intro to CS that I enjoyed way, way more than CS50.
Pay attention to the lectures and section if you want to spend less time on problem sets.
Start the psets as soon as they are out!
If you aren't positive you want to major or secondary, stay away.
Really good class that improves coding skills. Very different from CS50 -- doesn't just focus on getting code to work, but rather on it being elegant. Also more mathy and thought-intensive than CS50. I wouldn't necessarily say harder -- in fact, I spent less time on CS51 than on CS50 (which was my first coding class ever and therefore very hard), but definitely different.
It is a really good course. You learn a lot from it if you are willing to spend time. OCaml might be useless language in a real work application, but it teaches you something that other languages cannot.
Better than CS50, but not great. The content was interesting and actually teaches you how to be a computer scientist versus a code monkey, but overall, the way they graded assignments and midterms could be much better. I also felt very distant from the course staff and didn't feel like people cared about how well I did in the class or my learning at all.
Use your late days! You can only use one per p-set and at the end, you might have all of them left.
Start on final project early. Problem sets are very time consuming and be prepared to spend a lot of time coding/debugging, which can get frustrating. Morrisett's a really cool guy too, but he's unfortunately not going to be back next year, so hope that the new professor is good.
CS51 is a very well thought-out course. It expects more of you than CS50, but I felt that the psets were often more rewarding than those in CS50. I believe there will be a new professor next spring and a hearty restructuring of the course, but I really enjoyed it in its current form.
CS51 is a good class. It's hard and definitely time consuming on the problem sets, but you do learn to become a wiser programmer. Learning Ocaml is fun and practical. Final project can be fun if you work with a good team. No reason not to take it.
This is a great class, one all CS or EE students should take. The psets can be long, but you really feel as if you are learning how to think and program, not just code. Great class.
Great class to take if considering more CS - much more representative than CS50. I learned how to think in abstractions and modules, how to code elegantly and safely, and what the frontiers of CS in industry and research are, so in all those respects I think the class was a great success at its mission. Prof. Morrisett was a great lecturer and explained concepts very clearly, and I appreciated that the psets were more manageable this year compared to previously (as I heard from past students).
I feel like I didn't make a very good choice by choosing this class. However, that's maybe a consequence of my schedule as a whole. Be sure to have time to work on the problem sets and to practice everything you learn. I didn't find lectures to be very useful  and they were a bit confusing. The problem sets are the real tools for you to learn.
The lectures are helpful and interesting. Towards the end the lectures are really fascinating as they broaden out from direct explanation of OCaml (though that is very helpful for psets, etc). Morrisett is an amazing professor, there is a lot to be learned from him.
If you're unsure about a CS major/minor, then this class will tell you if thats the right choice.
Its hard but worth it.
I averaged 2 hours of sleep on Thursday nights the entire semester. But I feel much more confident in my coding skills and ability to learn new languages. Functional programming is worth learning and this is a great class to really get to know it.
This is a great class for people who want to know more about CS outside of CS 50. Given that, it is a very different experience from CS 50 in terms of approach to problems sets and time commitment.
Dr. Morrisett is absolutely awesome and I'm very sad to see him leave Harvard for Cornell.  His lectures are fun and engaging, and I'm such a better programmer and computer scientist in general after taking his course.  He's affirmed my desire to be a CS concentrator.  He's also a great source of info about a variety of CS courses (and Harvard in general) and truly cares about advising you.  The only thing a bit troubling in the course was that the TF's were late uploading p-set specs and final project checkpoint specifications, making a couple due dates a little tight.  However, TF's vary year to year, so we just had bad luck.  The class curriculum is rumored to be changing with the change of professor for next year, but if whoever takes over the class is anywhere near as good as Dr. Morrisett, you will love this course.
CS51 was a big step up from CS50, in multiple senses of the phrase. It is so much better in terms of the content, if you're at all interested in studying computer science. While CS was kind of a joke, CS51 is a real class, and each pset is both difficult and interesting. It's also significantly harder than CS50, but in a good way. I enjoyed this class.
Solid class, more abstract/mathematical than CS 50 but otherwise of similar difficulty. Find reliable partners for the partner psets/project.
This class teaches you to program well. It's not just about getting the writing answer, but writing beautiful, elegant code. It won't come that easily and will take a lot of time but this class will make you feel prepared to learn any other type of cs. It won't inherently teach you much that is going to come up in everyday life, but the programming mentality that it teaches will be useful in any other type of programming.
I personally found this to be a much better class than Cs50. Gone are the flashy videos and dubstep recitals, replaced by actual computer science (thought the fact we are using OCaml beg's the question of why no one else except Jane Street uses it). Also, Professor Morrisett is hands down the man, and the first of my professors that I would consider an absolute genius.
I was highly disappointed in this course in many ways.For one, the course supposedly levels the playing field by choosing the obscure functional programming language OCaml as the language for lectures and assignments. I found this to be false, and students with less programming experience were still at a huge disadvantage. It seemed that this class was more of a partnership with Jane Street (quant. trading firm that uses the obscure language OCaml) than anything else.Lectures were very difficult to follow. The powerpoints that Morissett uses are very lengthy, and he covers the slides too quickly for most students to follow. Fewer and fewer students attend the lectures as the semester progresses, and one of the contributing reasons is that they are difficult to follow, and students feel that they will only learn by completing the problem sets.The assignments were too long (10-20 hours/pset) - again, students with more programming experience were at an advantage here. It is not reasonable to need to go to office hours multiple times a week in order to complete assignments. Students were forced to go to office hours in order to obtain help from the teaching fellows. The experience at office hours is not pleasant. Most teaching fellows were more interested in moving on to the next person rather than taking the time to help students understand concepts. The ratio of teaching fellows to students is too low, especially nearing the end of the week when psets are due. The end of the semester should not have both a final exam and a final project. Students learn more with the projects and the final exam is just another burden to worry about at the end of the year.
Tough, yet very rewarding class. Take it if you're interested and have the time.
An excellent followup to the outsider-friendly CS50. Explores much more sophisticated ideas in the field with satisfying depth. Problem sets typically just as tedious as CS50's (feel shorter because people have gotten used to CS psets), but with more challenging core ideas. This was the last year taught by Professor Morrisett, so the quality of instruction in future years is up for grabs.
I learned a lot but it is very challenging and demanding. Take this as early in your career as possible if you are considering studying CS at all. It is a make or break class I believe in if you want and are capable of doing it for four years.
easy as shit if you know how to code
It is challenging, but rewarding. The psets can take a long time so you need to plan ahead of time, but the staff, and professor morrisett were phenomenal. I felt like there was always a community to help me (whether it be my peers, piazza, or the tfs), and that really molded CS51 into a great experience.
If you have background in programming you should probably skip this class. It felt like a couple of week's of material stretched over a semester.
51 introduces a lot of interesting concepts in functional programming and at times the tasks at hand are really cool and a new way of looking at computer science. However, students are largely left to stumble through them without a lot of support. Office hours are crowded and often not helpful and Piazza is a keep-your-fingers-crossed game. I'd highly recommend going to section each week and emailing your TF personally with questions, this is by far what got me through the class.
This class will teach you to become a better programmer, write cleaner code, and think in a higher-level functional way. It's also a prerequisite for a lot of other CS classes, so yes, I would recommend that you take it. However, know that it is no walk in the park. There are no frills like CS50, which means that the opaque problem set instructions barely relate to material taught in lecture, office hours are an absolute nightmare, and the course staff are often demeaning and condescending. Taking 5 classes this semester, I found that I couldn't give this class the attention and time it deserved and feel like I could've gotten a lot more out of it if I had taken less classes. I would recommend taking it because you do become better at programming, but also understand that it will be very frustrating at times.
This class is VERY DIFFICULT! Don't be fooled by the Q score. I only took CS50 but had no experience prior to that and I really struggled in this class, maybe 15+ hours per pset. This class is definitely not CS50, but you learn so, so much. Overall, you learn a lot from this class  , but I struggled way too much (Also make sure you have a partner to work with).
CS51 is the serious, hard-working older sibling to fun-loving CS50. While some might find the workload to be arduous and the lectures to be a buzzkill, I nonetheless ended up getting a lot out of CS51. OCaml is a beautiful programming language and you will learn to appreciate writing two lines of code that accomplish the equivalent of ten lines in most other languages. While you will probably hate the late nights in the Science Center basement working on problem sets, the brutally long queues at office hours, and the demoralizing test questions, you'll learn a lot about the art of coding and good design. Also, Stuart Shieber, who did not teach this class my year but is starting next year, is a fantastic professor, and I have full confidence that he will restructure this course to make it much more engaging.
-
If you don't have three hours/day to dedicate to this course or an extensive CS background, don't take it. This course might be enjoyable if you have the time, but if you do a lot of extracurriculars and take other time intensive classes, DO NOT TAKE IT.
I loved 51, much more than 50. I don't think Morrisett will be here in the coming year, but he is amazing. I loved the lectures, which were always engaging and comprehensive and clear. His dry humor makes class interesting, and it's clear that he is passionate about the topics and cares a lot about the class. The assignments are thoughtful, but for some of them it gets convoluted very quickly--the testing is harder than the actual assignment. I learned a lot about design and functional programming. There is a learning curve in the beginning, but once you get it, it's pretty smooth from there. Take it!
Great class with Greg Morrisett!
Great class, so much better than CS50!CS50 is just glamor. CS51 is COMPUTER SCIENCE. You finally get to do cool stuff, instead of writing HTML and CSS code. Absolutely worth taking.
Understanding functional programming is necessary. It's a good continuation of CS50. TAKE IT!
I loved this class!Relative to CS 50 this class feels a lot more...controlled. Office hours are a lot more chill than 50. Also, the partner aspect for the last four problem sets is pretty nice if you have a partner who pull's his/her weight and is fun to work with.I had coded a bit in R and Python and took CS 50 before this, and felt this class gave me some concepts will be super useful down the line, such as objected oriented programming, ways of thinking about performing operations over data structures, basic algorithmic thinking, abstractions, memory management, and style.This class felt a lot more manageable than CS 50. You should really pay attention to the style guide so as to avoid getting points docked off.I recommend taking this as early as possible since the concepts learned in this class will translate to other courses that involve coding and will doubtless be useful in internships.
This class and functional programming are fun. I found that my mathematical preparation (i.e. "proof-based math") was more useful / more helpful for assimilating the material quickly than my coding skills. I think.
It will demand a lot from you, but it will give you so much in return.  Also, Professor Morrisett does a great job of connecting the material we learn to real world applications, which provides good motivation for learning the material.
This is a very good introductory class. I highly enjoyed learning the material however I feel like it took lots of my time this semester. Dr. Morrisett was also a great lecturer and I would definitely recommend the class though I don't know how much it would change next year with the new professor.
This really is not CS50. It's much more rigorous, and you walk away feeling like you have learned some of the more serious parts of CS and functional programming. Unfortunately, the course has brought upon me the great disappointment that not everyone uses OCaml, and it is only recently that I have stopped shedding tears over the inability of other languages to support proper first class procedures. Overall, a solid course for anyone looking to get more serious about coding.
This course covers really important material and is a great foundation for some of the higher level courses.  It's awesome that it is taught in a functional language!
You will be frustrated by the fact that OCaml isn't particularly applicable to the real world, but see CS51 as an opportunity to stretch your mind.
This class offers a fascinating view on a whole different type of programming, functional programming. The class is structure pretty well and the final project can be extremely enjoyable.
Very good class that teaches good programming design practices through the scope of functional programming.
Sure, you can take this class if your only experience is CS50. And you can even do well in this class if your only experience is CS50. But this class is so much easier (or just plain easy?) for those with coding experience beyond CS50, which can be intimidating, at times, if all you've done is CS50. The problem sets also take forever (15+ hours) if you are fairly new to coding. But learning OCaml was kind of cool.
This class is the bomb. Unfortunately, Greg won't be teaching this class in the future so it is hard to say whether this class is worth it or not. Honestly, this class is not really a prereq to a lot of the other CS classes in the undergraduate series so if that is what you want, go for it. But the class this year was very enjoyable and I had a great time doing the psets. They were actually enjoyable and not painful. The class was very enjoyable and it is very important to find a good partner for the partner psets.
This is a well crafted and rigorous course that introduces you to key ideas in computer science (in a way CS50 doesn't), and gives you a shit ton of practice coding and debugging on the problem sets. Everything you've read/heard about how much time it takes up is true. The final project is fun because you get to explore whatever you want. I had such a hard time not getting rubbed the wrong way by Greg's slightly pompous style that I stopped going to lecture, but I think if I had gotten over that I could have gotten even more out of the course because he has a lot of knowledge to share. Go to section as they are super casual and helpful.
If you have taken CS50 and you are wondering what 51 is like: it's better. The workload in CS51 is actually a lot less than CS 50. Also, I found that 51 is also thought in a lot better way. You probably know that 51 teaches you a very useful stuff that will be extremely useful whenever you want to use your CS skills so if you survived CS50 and you found it even slightly interesting, take CS51. It's gonna be more enjoyable and more useful.
Start early on the problem sets.
Problem sets start out interesting, but toward the end tend to get very confusing as the class attempts to use OCaml to do things that OCaml really wasn't built to do.  The use of OCaml is also pretty confusing, as really no company except Jane Street uses it (hint: they sponsor the class).  Lecture can be interesting but you have to make sure you actually pay attention.  Also, take into consideration the fact that Morrisett is leaving!
This class is fantastic. While functional programming may seem daunting and irrelevant at first, it's incredibly useful, and the psets in this class are fun while being instructive and challenging.
It's very tough, but it's worth it for all the coding experience you receive.
CS51 is a great class and should be taken by every student who intends on concentrating in computer science. The problem sets will take out a big chunk of your week, but they also teach you so much. A lot of people come into the course skeptical of Ocaml, but it's truly not the language that matters. CS51 covers essential concepts like abstraction, polymorphism, inheritance, and parallel programming, and it teaches you how to write elegant, readable code. Although I don't necessarily recommend this, I did not go to lecture and survived just fine (you can read lecture slides and even watch the lecture online at a faster speed if you want). It's a challenging but ultimately entirely doable course that teaches you a whole lot about programming. Take it.
If you have a strong CS background you are unlikely to get very much out of this class. OCaml is an ok language but your time is better spent learning functional programming ideas than OCaml syntax.
this course made me not want to take any more cs courses
The true introduction to CS. If you know some tini bit of programming skip cs50 and take this.
Definitely a lot of work, so be prepared.  As long as you spend enough time, it's not really difficult conceptually.
Probably not the best course to take. You can learn the necessary data structures and practices using other, much more friendly languages.
It's a great course for learning interesting CS basics and definitely requires you to stay on top of your game.
This is a great class. If you're interested in pursuing CS at Harvard you should definitely take it. L
Take this if you are considering cs as a cocentratiob
Extremely difficult but rewarding
This is difficult class. The problem sets take a lot of time (expect about 20 hrs for some of them) and the exams are tough too. Lectures can be pretty boring. You will be competing against the best students from CS50, or other with more prior experience, so  you will be challenged. A very important class for anyone thinking of concentrating in CS. Ocaml is practically useless for the real world, but the general concepts 51 teaches are very applicable and fundamental to becoming a better programmer.
CS51 is definitely designed to be the centerpiece of a student's schedule- the courseload is insane and the class environment is sink-or-swim. You'll learn a lot of very important computer programming concepts, so I recommend the class to everyone looking to concentrate in CS or related fields, but I found the class extremely discouraging, disorganized, and tough to balance along with my other classes. Taking CS51 will really tell you whether or not you want to continue with CS.
Make you a better coder. A true CS course. Compared to this 50 is so basic
If you're really smart, then take it. If not or you don't want to work hard, don't
I would highly recommend this course to anyone interested in further exploring their interest in computer science. This course really enhanced my love and enthusiasm for pursuing higher level computer science courses at Harvard. Rather than just teaching you an interesting language, syntax, and domain of computer science, this course challenges you to think like a computer scientist. There is a huge emphasis on problem solving, but the best part of the course is how supportive the faculty is. There are countless resources put in place to help you succeed, and if you put in the effort, the course staff is there to support you. That being said, the material can be very challenging and the course definitely requires a lot of time. However, it was a very rewarding experience.
You'll find out whether or not you're a CS person. I - painfully - found out I wasn't. This was a pretty painful experience. Everything about it is hard. The first few psets lull you into thinking things are okay, but then it just gets insane by the end. I felt extremely out of my element. I would tread lightly with this course. Shop it. But if you do take it, make sure your other classes and extracurricular commitments are manageable. And I would say, considering the fact that I don't feel like I learned a ton, it probably isn't worth dedicating your life to a class like this for a semester. If you did very well in CS50 and have a very solid CS background, you'll probably have a very good time.
This is a much harder class than CS50. The problem sets will take much longer and are more difficult, requiring you to spend all of Thursday night finishing them. I think the material the class covers is good, but be ready to spend a large portion of the week working on the pset. This is definitely not an easy class for those with no prior coding experience (even with CS50) and the lectures will often be confusing until you see the concepts in play during the problem sets. The class is also very back loaded since it has a final project and a final exam.
Much better than CS50 if you are an academically serious person.
A great introduction to better design and abstraction in CS, heavy workload with lengthy problem sets, but manageable within deadlines.
Great class that teaches fundamentals about programming and code design very well.
The problem sets take a very long time and can get really difficult, but it's a great course for anyone interested in CS to take, and there are office hours four nights a week for problem set help.
Takes a lot of time and can be daunting at times, but you learn a lot.
Take it!
Be prepared to work hard, but get a lot out of the class. This is a class where you get out as much as you put in.
Be ready to work and learn a lot
Good introduction to functional program and recursion, but do not expect the TFs and the professor to hold your hand like they did for CS50.
Stay on top of the problem sets. They sneak up on you if you don't start them early and it's terrible pulling all nighters on Thursday nights. It's a lot easier to skip lecture and watch them at 2x speed online instead. The exams are nothing like the problem sets. Study hard, they are not easy.
Tough, the psets are brutal but you learn a lot and become a much better coder. Easier to get through on your own than CS50 which I did really like.
Tough class. Not sure how it will change with the change in teaching. Definitely made me a better programmer, totally worth it if you want to continue with CS or at least check more of it out. CS50 definitely tries to bring everybody into CS, CS51 tries to weed people out.
Taking this class after CS 61 was a little underwhelming.  It did introduce many cool things one can do to make beautiful, functional programs, but CS 61 had already covered these, and in more depth.  The class felt more like an OCaml tutorial to me than a second introductory course in computer science.
I took this as a concentration requirement since I skipped CS50. (two of CS50,51,61). Don't. If you are smart enough to skip CS50, you do not need this class. I would recommend learning a bit of functional programming but this class wastes a lot of time on things I already knew. At the end of the day, what I learned from this class could be summed up in maybe a week.
The course covers very good topics and makes you a programmer of efficient, elegant code. Every homework teaches very useful algorithms. Ocaml is a great language to learn and write algorithms.
This class isn't that great. What you learn is useless.
I did not enjoy this course at all. They throw you right into OCaml rather quickly with the first couple psets. Lecture is not useful because Greg rambles a lot and he is not engaging. Read the lecture notes and don't even bother going to lecture. Section is actually useful (plus you get free food) so go to that.
This class is very difficult!  If you are interested in CS, it is certainly a good barometer for whether you should concentrate.  Be prepared for a lot of late nights, however.
This class is extremely difficult but also very interesting.
Really interesting material - I learned a lot and it taught me to think more analytically. Worth taking even if you never use OCaml again, and Morrisett is the best! :)
Hard and very time consuming.
Take but prepare to struggle. Do not take if you have any other time-consuming courses. This one needs ALL your attention all the time
Makes you approach problems differently
You can learn most of this material on your own in a week. But I guess this class forces you to sit down and do so yourself.
Engage with every day of the class. You can't afford to wait until the exams to do so. Don't fool yourself into thinking that doing the problem sets will be enough. It's possible to hack away at these without really understanding why things are or are not working.
Lots of fun!
Great class, especially with Morisett. You'll learn to appreciate some of the great features of OCaml. Solid foundation for future CS classes.
CS50 gets people to like coding. CS51 starts to teach you how to actually do it.
This is a difficult class, it's really important to get a good problem set partner and to attend office hours even if you don't get the opportunity to talk to the tfs it's incredibly helpful to work in groups
A great follow-up course to CS50, Morrisett is a great professor that will make you really appreciate functional programming and make you excited about its applications. Unfortunately he is leaving after this semester, so who knows how it will be in the fall.
This class is a lot of work and at times can be very difficult, but I thoroughly enjoyed it.  The teaching staff is excellent and I really feel like I learned how to be a much better programmer because of the class's high standards for our code's correctness and elegance.
CS51 definitely is not CS50 in terms of the content that you will be learning. There is still some hand-holding in terms of coding---it seemed that a slight majority of students come into the class directly from CS50 and expect the same sort of infrastructure for assistance. My advice would be to figure out how to do everything yourself instead of relying on office hours and sections---the median/average raw score on problem sets was in A-minus/A range but the median/average raw score on the exams was about a C-minus. In other words, a huge discrepancy between performance on problem sets and performance on exams. However, if you do end up stuck on a minor bug on the problem set then just go to office hours---the small bugs aren't worth your time in the course and you could be better off just studying. Lecture videos are posted online very quickly and sometimes it may be more useful to just watch online instead of going to class since the classroom can sometimes be overpacked and you may not get to find a good seat to listen and take notes. In fact, for the midterm, we had to take the test side-by-side with no seats between us in one of the larger Science Center lecture halls.
I was told how awful this class was going to be, and how useless ocaml would be and I ended up loving it. This class levels the playing field by using a language no one knows and makes you go from knowing how to code to knowing how to code well. Since taking this class I would definitely say I have become a much better programmer.
Pay attention in lectures and section. Ask questions. Start psets early
Yeah... not a fan.
Do not take this class lightly. It is a reasonably difficult class with relatively sound grading, but understand that this class will take about 10 hrs a week and a lot of diligence. The psets are not so much difficult as time consuming in the sense that a lot of discipline is required in tying up loose ends on psets, making sure the code isn't just functional but good, that tests are extensively written, not just to write them, but to think about logically what cases should be tested.
If you enjoyed CS50, you will most likely enjoy 51 even more. I thought the teaching staff this year was excellent
This class was one of the most intellectually challenging courses I have taken at Harvard. I put in hours of work each week, will not get an A, and I do not regret taking it at all. I hope the teaching staff gets a bit organized in the future and that the lectures become a bit more engaging, but I felt I learned a lot and thought a lot as a direct result of this course.
Pretty similar to CS50, but without the frills. A somewhat inefficient way to learn, but plenty of support if you need it.
This class is a ton of work. The homework assignments take forever to complete. At the end of the class you definitely have learned a lot, can approach coding in a much more organized way, and can think about problems in a better way, but getting there is really annoying if you have a lot of other things going on.
If Tov is still teaching this class don't bother going to lecture and pray you have a good TF.
Very poorly taught. The TFs are highly unprofessional. Honestly, I felt like a handful of them needed to be taught by some of the students. Quite sad that Harvard couldn't find better people to have such crucial tasks.Unless new people are put in charge (other than Ben, he was definitely good), I wouldn't take this class.Also, whoever made the second midterm can definitely go away, as well. Unacceptable.
If Jesse Tov is teaching this class, DO NOT TAKE IT. If Morissett is, (I watched his lectures from last year), TAKE IT!
As per usual with the Harvard CS department, be prepared to teach yourself, struggle by yourself, and fail by yourself. There are too many students, too few TFs, and too few hours in the day to complete your assignments. If you go to office hours, be prepared to wait in a 2-hour line to get 5 minutes of help. This class has confirmed my suspicion that the extension school is ruining classes for the real Harvard students. Half of the TFs are dedicated to the extension school, so they can have online office hours in their rooms without having to help anyone. Due to this unfairness, there are usually 2 terrific TFs at office hours, surrounded by 100+ students, and they can't possibly help everyone. It is survival of the fittest, and if this was natural selection, most of us would be going extinct (myself included). I am very passionate about CS, so I am sad to see the quality of this class deteriorating.
This class will probably make you smarter, so take it.
requires a lot of effort, but worth the time
It takes a fair amount of time, don't take it along with numerous other hard courses.
It's a good class.  The material is very cool, and I came out genuinely liking OCaml.  That said, it moves a bit slow sometimes and some of the psets are more tedious than hard.
It is a lot of work, but in the end it is totally worth it. Before entering the class I knew next to nothing about recursion and its uses. Upon completing the course I can honestly say that my understanding of CS concepts and my approach to problem-solving has changed for the better!
I don't know how much I actually get out of the class. It does give me some programming maturity but after all Ocaml is a useless language unless you want to work for jane street. If you feel you are good at CS and good at picking up things on your own, skipping the class may not be a bad idea.
Lectures are very very boring and pretty useless--Tov just stands at the front of the class and codes on the projector. Assignments are rough, but I learned a lot from doing them.  Manage your time wisely.
great class, very useful.ocaml rocks
Take this class if you want to become very proficient in OCAML, understand data structures, and slightly expand conceptual knowledge from CS50. But don't take it if not willing to put many many many hours to psets.
This is a great course as a follow up to CS 50. My coding and understanding of CS have improve dramatically. The course was a little disorganized this year, but the material alone is worth taking the course. And OCaml is actually pretty cool.
This course is a waste of your time--if given the option, definitely skip to CS61 or CS121/CS124/CS125 (the former if looking for a more "applied" course and the latter for more theoretical courses). This course attempts to teach functional programming through an obscure language called OCaml in an attempt to give everyone an even playing field (notice the liberal use of the word "attempt"...). While it gets the basic idea of functional programming across, the course is misguided from the beginning--OCaml is a language you will likely forget immediately after this course as it is used almost no where in industry (other than Jane Street), PSETs are long and boring, and graded feedback takes literally months to get back. Lectures are long and boring (which will hopefully change with Professor Morisett's return, whom I hear is good), and practically everyone skips. Like you should. Into CS61.
Not particularly useful if you have a lot of coding background, but for people going from CS50 who started CS in college, it is very helpful. Start the psets early, before Thursday as Thursday OH are always very crowded.
This is a great class.  Coming from someone who didn't like CS50, this class really turned me back on to Computer Science (now a concentrator).  The psets are really interesting and you do some pretty cool stuff.  In regards to partners, MAKE SURE YOU PICK A GOOD PARTNER.  It can be really frustrating if you guys have different schedules and/or you have to do most of the work.  Other than that though, it's really an awesome course.  Lots of time, but definitely worth it.
CS51 is a really great second semester CS class that cements a lot of the concepts you introduce in CS50. Its workload was similar to CS50, but that shouldn't discourage anyone not to take it. All in all, I enjoyed section, thought that the final project was a lot of fun to work, and there is so much support in the teaching staff.
Morrisett seemed like a very charismatic lecturer compared to Tov. I would have liked to take the class with him. Nevertheless, section/problem set material was about the same, so I feel like I still learned the material, which is useful to know for any CS concentrator or student with interests in CS.  A little knowledge of functional programming might help, because at least this year, they threw us in (and threw Emacs at us too) without any help, and it took a lot of struggling to get off the ground at first.
It's a lot of work. Balance this class with easier classes.
CS51 teaches you some very important and core concepts to programming. This course helps you to become a better programmer, and this is undeniable. The assignments were good overall (a few psets were not very well written but for the most part it was solid) and the final project was exciting. This semester, transparency on grading was pretty unclear, which made the course unnecessarily difficult for students. Students didn't get their pset results until many weeks after, which negatively contributes to their current pset grades since students don't know what points/areas they are missing and need to improve on until it's already too late. Hopefully, the teaching staff can fix this for next year's students. Overall, I enjoyed the course, learned some tangible skills, and am looking forward to taking more CS courses soon.
This class will teach you to code better, but keep in mind that you will need to put in a considerable amount of time and effort. You truly get out what you put in to this class. If Jesse Tov is lecturing, don't bother going, but definitely go to section, as this is where most of the learning will occur.
Useful in the sense that you get a lot of programming practice, but lectures weren't the most compelling. Take it if you want to become better at CS, not if you want to like it more.
This is a good class, but OCaml can be frustrating at times. There is a bit of a learning curve at first but once you get the hang of it you actually learn some cool class. It is definitely tough at times and very time consuming, but it will make you a better programmer.
This was an interesting class. It was great coming into the class knowing nothing about OCaml or functional programming and accomplish some really impressive things over the course of the semester. That being said, the psets mainly consisted of a lot of elaborate code written by the teaching staff, which we were supposed to add to/edit. Although the code written by the staff gave us a nice head start so we could accomplish some pretty cool things, it also severely limited the extent to which we could be creative with our solutions because we had to conform to the code already written. I would have rather had more freedom in my programming, even if it meant my end results for the psets were less impressive. The final project was great for having freedom. While Jesse's constant examples during class were helpful, it would have been better to have some kind of more structured curriculum, perhaps with a textbook. My biggest complaint is that office hours were a complete madhouse, especially on Thursday nights. Over 50 students would be in line to talk to one of three TF's, which meant it could take over an hour for a TF to come to you, by which time you're likely in a completely different part of the pset than when you got in line. Something definitely needs to be done about that next year. Grading of some of the psets was unbearably slow. I think it took the teaching staff over a month and a half to get one of the psets back to us. Also, Rob is the best and if you go to his section you'll do better than the students in the other sections.
This is a solid computer science. I enjoyed it so much more than CS50 due to the depth of the material and the organization of the class in general.
This course is a good introduction to computer science - take it instead of CS 50 if you want such an introduction. CS 50 is definitely not a prerequisite, and CS 51 fairly well identifies the parts of coding that are helpful for people to learn. In terms of negatives, there were a number of logistical issues this year (as is the nature of all large courses), and there probably will be next year, too. If you're willing to put up with these (they aren't that bad), then this course is definitely worth taking.Also, students who want to take this class should preferably not be too afraid of math - not because you do a lot of math in the class (you don't), but because much of the thinking in CS 51 (in functional programming, really) is more similar to mathematical thinking than the CS-50-programming kind of thinking. If you're a bit worried about this, CS 51 will probably still be fine, but you may find it a bit more difficult.
If you're just trying to get some secondary credit, there are other CS courses to take.  Sometimes I felt as if I wasn't learning things that were that practical.
You should absolutely take this class. I felt like CS50 gets you really excited about cs, which is great but I didn't learn that much. You learn a great deal in cs51, the material is fascinating and it makes you more confident in your coding abilities.
Work on your psets early. Go to office hours. Ask TF's questions (email them, stay after section, etc) if you don't understand anything. For the psets that allow partner, choose someone who is at the same level as you in term of programming. If there is no one, do it alone because you learn from doing psets.
Working through the problem sets is actually pretty fun, though strugglesome.  You should take it if you can put in the time!
very hard need to build your schedule around it with other easy classes to balance it out
This course is one that every computer scientist either must take or otherwise learn the content in. Being able to program in a functional paradigm is crucial, and is impacting how I think about solving problems in computer science.
This class is well designed, and comes along with a sizeable workload. You'll fully master recursive programming by the time the course is over, and your overall programming abilities will definitely be improved. The tf were extremely helpful on piazza, but were atrocious at returning assignments on times. At one point, we went a month and a half without receiving a single piece of graded work.
This is a great class, however Jesse Tov isn't a great teacher, so only take it when the other teacher is teaching it
A worthwhile course to take if you are newer to programming and do not understand computer languages. A useful course if you are a developed programmer and want a more thorough background in computer languages.
Class has interesting psets and very helpful teaching staff. Lectures were also pretty clear.
Easy, interesting class. Learning the new functional programming paradigm was useful and enlightening - it really opened up a new and quite intriguing side of programming.
The difference I noticed between this class and CS50 in terms of the workload was that 50 gives you one large problem to solve that you scramble and stress over for the entire week, while 51 gives you many smaller, self contained problems that occasionally amount to something interesting. This made the problem sets a lot more enjoyable and less stressful. They say that this course is the make or break CS class, and in my case it definitely made me know that I will be declaring CS next winter. It provides a great introduction to higher level programming concepts, gave me the ability to appreciate them. Specifically, abstraction is mind-blowing, functional programming is beautiful, and object oriented programming is really fun. If these things do not sound appealing, however, do not take this class.
You can get what this class teaches by reading 4-5 chapters in any programming book. If you're totally clueless with computers, then take it so you can be introduced, but if you at all know what you're doing, don't waste your time.
This course is hard.  Make sure you are a really strong programmer beyond CS50 level.
It is important to know other people who are also taking the class. If you don't know anybody, make some new friends. Having somebody to take the class with can help a lot with understanding the material. The later problem sets will also allow partner collaboration.
Start the problem sets early
This course will tell you whether you like computer science enough to pursue more classes in it. The amount of work and energy you have to put into this course are substantial, and by the end, you will be very clear on whether you think programming is worth all the effort. For me, I found that computer science is not my thing. Many other people found that it was. Definitely take this class to find out if you're on the fence.
CS51 does not have very interesting lectures and most of what you learn in the class will be from problem sets and section.
Take it, you'll learn to think a lot!
Only take this class if you're really interested in computer science. If you're expecting something like CS50, CS51 is much harder and is much less of an "intro" class.
If Professor Tov is still teaching the course, don't expect much from lectures. The class is otherwise reasonable. Problem sets are interesting enough, and instructive enough that lectures aren't necessary to your understanding of the material. Later problem sets can become pretty time consuming, and negotiating time expenditure for partner psets did become a little complicated, but it worked out in the end. Midterm exams are pretty fair in terms of difficulty level. The course isn't super painful - the material is pretty accessible, and the TFs can help explain any concepts that weren't conveyed clearly in lecture. Still, there were moments throughout the semester - maybe a particularly dull lecture or a time consuming pset during a hectic weak - where the course seemed extremely frustrating.
CS51 is definitely the next step after CS50. Its much more like what I've been told other courses in the department are like and its definitely a good introduction to what more advanced CS courses will be like
This class is tough. However, you will leave feeling like you actually learned something.
This class has been my favorite at Harvard so far. All of the decorations and trimming that made CS50 so fun are taken away, but that's not necessarily a bad thing. This class is meant to show you that CS means business, and it will demand a lot. You'll spend many hours a week on psets. But that's the point of the concentration; it expects a lot of its students. I have heard that this year's class was made a lot more manageable than last year, and after talking to my roommates who took it last year I would say that I agree. At no point this semester, despite the heavy workload, did I feel overwhelmed. You will learn a lot lot lot from the psets and from going to section. Lecture can be a little convoluted, and office hours are very busy so go early in the week. This is all nitpicking though; I had a great time in this class.
This class was definitely more conceptually difficult than CS 50, but seemed worth taking. I learned a lot about functional programming and abstraction, and the problem sets forced me to think a lot harder than I did in CS 50. That being said, it's not overwhelmingly hard or extremely time-consuming, and I thought it was manageable.Dr. Tov seemed to be a very controversial lecturer. I honestly thought he was fine, and his lectures seemed to convey concepts understandably (for the most part) and precisely. However, others seemed to disagree, and I may be in the minority here.The one main issue I had with the course was that I'm not entirely sure what I learned, at a broad level. For instance, I learned a lot about specific syntactic and structural features of OCaml, but I still don't know why those things matter more generally.
It's a good course overall.
know that you can take cs61 instead in the fall
This is a solid CS course. Functional programming is great, and it's good at teaching it.
CS51 is a tough class with extremely long psets.Be prepared for a typical CS class: you won't learn that much in lecture that will be useful for the psets; you'll hope you get a good TF who helps you prepare for the psets in section; you'll hope you have smart friends who can help you through the psets; and you'll have to study random stuff for the mditerms that doesn't really have too much to do with what you actually learned.
The problem sets really made me think and I think you will feel good when you complete them. OCaml is such an elegant language that I am sure you will come to appreciate.
I'd never taken a formal CS course, so I thought it would be a good idea to start with CS51. I wasn't disappointed; my coding skills surely improved. However, if you're looking for a course with immediate usability, look elsewhere. OCaml is not exactly a widely used language.
While this class is definitely more difficult than CS50, I think it really makes all the work worth it. You learn a lot more that really gives you power to make interesting programs. Lectures are not that exciting, but they're definitely informative. Problem sets are pretty time intensive (at least 10 hours a week but often much more), so make sure that you have an easier class to offset this workload.
Take it if you're planning to concentrate in CS. I would think twice about taking it as an elective -- for me, Ocaml seems like it's not that helpful to learn just for the sake of learning.
Watching the lectures for this class on YouTube in 2x is the way to go, as with most CS classes. Give yourself plenty of time (and make sure you have partners for certain problem sets) and the homework is not too challenging. There's more emphasis than you'd expect on theory and data structures, which is great preparation for future courses like CS124 but not very interesting. Overall, it's a requirement you'll have to get done if you're a CS concentrator so you might as well make the best of it. For those expecting another CS50, welcome to the real world. If you don't like this class or find it too difficult, then rethink being a CS concentrator.
You'll learn a ton in CS51 without realizing it, up until you use what you learned on the final project, at which point you see how it was useful. The most important part of the course is finding a good partner to work on problem sets with (good meaning capable at CS and also easy to coordinate with). Make sure, though, that you're still learning all of the material while you're working with a partner. It's easy to just let your partner do all of the hard stuff.
It will be unengaging if Tov teaches like he did our year. Take 61
This class is a disaster. Do not take it unless you actually have to. The grading is literally nonexistent. We were already working on the 5th problem set before we got any grades back for the first one. The lectures are ridiculously boring. Professor Tov should not be teaching. This is the most disorganized class I have ever taken. Just don't take it. For your sanity.
This is a hard class.  Make sure you have a partner with whom you can do your problem sets, as trying to do them alone is incredibly hard unless you have a very strong programming background beforehand.
I felt the class was most likely very different this year from past years, since Morrisett, the usual instructor, left. There were a lot of various other course changes such as a larger number of partner psets, restructured midterm formats (all were open book this year), and no final. Overall, the changes made the class easier than before in my opinion. The class was almost completely organized by the Teaching Fellows and Preceptor. That being said, the TFs/preceptor are extremely helpful, and many would spend extra hours helping students with psets or preparing for midterms. Psets generally take a long time, especially if you don't seek help. I would definitely go to office hours and use Piazza to search for similar questions or ask new ones. In contrast to the CS50 psets, I felt the type of problems on the CS51 psets made it more possible for TFs to help you, so office hours were more useful. Having a good partner is also important!
This course is a lot of fun to take, especially if many of your friends are in it. Coding is fun! It's also nice to be forced to write extensively in one language, so that you only have to check the documentation every other line. Unlike most of the students taking this course, I actually really like Ocaml. However, I don't feel I learned much in the class. Lectures were generally a waste of time. Although having to implement algorithms, classes, pointers, etc. was probably healthy for me, I'm not as independent a coder as I hoped I would be by the end. Because all of the assignments are templates, you only see in passing examples of good "design," and never actually have to design anything from scratch yourself.
Be ready to put in a lot of work into this course.
Take it only if you really like functional programming and OCaml. Be prepared to spend many late nights doing the PSETs.
The lectures were fairly boring and unhelpful, but the sections were great. You learn a lot from the problem sets. Also, I don't care what other people say, I think OCAML is a beautiful language. You'll probably never use it again though.
It teaches you OCaml... And little else.
Unless you're pretty confident with CS, I would recommend searching for another CS course. They don't hold your hand, like in CS50. Profs are also pretty ineffective.
Like many people have said, CS50 teaches you what programming is; CS51 teaches you how to program. It is an introductory course that covers more of the topics that are pertaining to problems programmers deal with on a day-to-day basis. And for that, I really appreciate the class. On the other hand, like some people, many people did not understand why there was a need for the programming language to be OCaml. OCaml wasn't bad, but many people did not find it to be practically useful, other than this class, and I totally agree. In terms of the lectures, I didn't attend them. The lecturer was frustratingly slow, in my opinion, and I often get out of lectures (for the times I did go) less excited to work on my psets than before. Whenever I did go, I was actually just working on my pset in class because I did not find much use in them. Sections, on the other hand, were drastically helpful. Even though I did not go, I realized towards the end how great they were. They solidified much of the content we covered in the week, and they give out REALLY good handouts for your midterms (yes, midterms are open note, but I'm not sure if it'll be different next year). Overall, I enjoyed the class more than CS50. Though the lectures were less entertaining and enthusiastic (in my opinion), I really liked the content because it gave me a better impression on what computer science and programming really means.
Great class, but the feedback on assignments was often very delayed.
If Jesse is not teaching then you should take it. Otherwise you won't get much out of the lectures, so be prepared.
A very time consuming class, but also very do-able. I would definitely choose this class over 61 because I feel like the concepts you learn in this class are more useful. OCaml is really cool. I do think that Jesse spoke a little fast and assumed that we knew more than we actually did about CS. His slides weren't that good either. But all in all, he did a pretty good job teaching this class--especially when you take into account that this is his first year teaching it.
Honestly, Tov was an awful lecturer. Awful. I stopped going to lecture and started watching videos, and often found that I understood things less after watching the videos than I did before.At the same time, I recommend this class with enthusiasm. I loved the material - even problem set 1 was really interesting. I think it's a great introduction to higher level programming, and the final project you will build will be much more rewarding than your CS50 project. It's really powerful to learn an alternate PARADIGM instead of just an alternate language, which is why functional programming is so fun to learn.
This class will make you appreciate functional programming, and that is a topic you might never see again as a CS student.
This was a really great CS class that I highly recommend to any CS concentrators or those seeking a secondary.  The concepts are well taught and the problem sets engage with you to really learn the material.  Grading was fair and while the first midterm was great, the second midterm (all true/false) was in my opinion a terrible way to test us.  The problem sets were very well done and really reinforced the material in lecture without being too difficult (however, some were time consuming)
Prepare to spend all of your time doing this class. It has easily been the toughest class I've taken here at harvard and required the most time. I would spend double the amount of time I spent on cs50 psets and would still end up getting stuff wrong on psets. Tests were reasonable, but the psets usually took around 15-20 hours. There were a few weeks with no psets which was great, but the class also 15 hour psets due both exam weeks.
The psets are by far the hardest part of this course. Tests were not that difficult. Second one was all true and false. The psets though, dominated the week, even working with a partner, which you do for almost all of them.
This class is a really good foundational class. Yes the psets are hard and the tests are equally difficult, but if you find a group early on in the semester and put in the effort (work every day for a few hours on the psets) then you should be fine. I liked this class a lot more than CS50, because it cut through the weird pretentious "trendy front" that CS50 set, and just teaches.
Coming to this course after having taken CS61, I was somewhat disappointed by the quality of instruction. The lectures were hard to follow, confusing, and not all that helpful. The assignments and this course as a whole is much easier than CS61, though. Section was great; I learned everything I did in this course from section.
It's much better paced than CS50, and as a result feels much easier (lectures and problem sets actually built off of one another)! However, if you actually want to learn about algorithms take CS124.
It's a somewhat challenging course, but it's definitely worth taking if you're interested in programming at all!
Good introduction to functional programming
Really fun problem sets, you learn a ton. In a completely different league from CS50 in terms of difficulty so don't underestimate it even if you breezed through 50. Lectures aren't particularly entertaining and teaching staff were good but pretty disorganized this semester so watch out for that. Go to section and do the psets early.
Such codes. Much OCaml.
Functional programming is definitely worth learning, and this class is helpful toward that goal. I do think, though, that some of the time spent in class is not used very efficiently.
CS51 is a great follow up to 50. Ocaml might seem like a weird language at first, but you really learn to love some of its features by the end of the course and the techniques you learn help you become a better programmer.
It's a really solid class to learn about OCaml and functional programming. It covers a lot of really useful concepts, and I felt like I became a better programmer by the end. However, I wasn't a fan of Tov's lectures. It's hard to engage yourself, but if you don't, it will hurt you for the midterms.
This course will eat up your life, especially the few nights before problem sets are due. In fairness, you learn a lot, especially because most of the psets require you to have a partner so that you're forced to look at how other people code. But be prepared to dedicate a lot of time to it. Lectures, at least this year with Dr. Tov instead of Prof. Morrisett, were rather unstructured and unhelpful to the problem sets or midterms; most of the learning came from doing the problem sets, which is part of why they take so long.
This year, the class was an absolute logistical nightmare. Sections and lectures were not worth going to, as the lecture and section notes were freely available online. It is a difficult course, but one could teach it to oneself quite easily. The proper teacher should be back next year, so it should be better.
CS51 is a big jump from CS50. You will find yourself spending countless hours trying to work through the psets. Make sure that you have a relatively light schedule to accommodate CS51.
CS51 is leaps and bounds better than CS50 if you already have programming experience. It's still manageable, and the problem sets are more interesting. The lectures are just as dull, which sucks. OCaml is an awesome language, and it's not something most programmers are exposed to so early on in their CS studies, but it's definitely worth it. Socially, CS51 sucks. You're very unlikely to meet new people in this course. I mean, you'll probably never go to lecture, and neither will anybody else. The only way to really get to know someone is to work with them on problem sets, but I know what you'll end up doing - you'll just work with that buddy you made in CS50 again, and poof, no new friends just like you're Drake or something. C'mon man, reach out and TOUCH SOMEBODY.If you thought CS50 was hard or too demanding, or you relied on your TFs to get you through it... good luck, dawg.
It's fun, especially the problem sets, and OCaml is a great language!
It was a good course and taught fundamental things about computer science.
Morrisett didn't teach this year and the class suffered as a result: lectures were confusing and hard to follow, a lot of small things needed on problem sets were never even mentioned in lecture, and OCaml is a black hole of mischief that detracts from the course. Java should be used since it's about 2^32 times more relevant in the world of Computer Science. The TFs did a good job though.
In my opinion, this class is a crucial step between CS50 and future, more intensive CS courses.
It's a good course and takes a lot of time but teaches you more abstract ways of approaching computer science problems.
Great class and certainly worth taking. Not too conceptually hard but there is a fair amount of work. If you like doing it, it goes by quickly but if you are not keen on CS it could be a pain.
Take this class if you have a genuine interest in computer science. As they say, this is NOT CS50.
Please for the love of Tov let someone else teach this class. The material is fantastic and I actually learnt real coding skills to complement the introduction that was CS50, but Jesus, bleeding Tov was a huge buzzkill
This is a great course to take for the first like three weeks to see if you'll like it. If you're interested in the language, then definitely take it, because it only gets more interesting from there on. If you absolutely can't stand OCaml, don't take this, because it will be very painful for you.
This course was seriously understaffed - we never got psets or feedback back on time (sometimes 6 weeks late). The course material was hard but there were not enough TFs at office hours - long waiting times. They also changed the nature of the exam to a new format which was really odd.
I would definitely encourage students of all programming backgrounds to take this course because it teaches you a new way of thinking about coding (i.e. functionally), which is super interesting. OCaml is also a great language. I would also say that potentially some people with CS background should consider not taking CS 50 and just taking CS 51.
I do think that everybody who wants to do CS to some extent should learn the material from this class. Students who are not that into web programming and have some level of mathematical sophistication should not be afraid of skipping CS50 and jumping straight into CS51 - understanding of logic is more important than tons of previous experience (and you really do not need to know C for this class). That being said, this is a big course and because of this it has logistical issues. It was not my favourite course, but I am quite sure that I enjoyed it much more than I would have enjoyed CS50 and it did teach me a couple of new things. This is not a "let's put on a big show and teach kids to make their own webpage" class, this is an actual beginner-level computer science class, and because of this I am "likely to recommend" it.
Though CS50 attracts lots of praise, CS51 definitely trumps CS50 in all respects.  The psets are more fun, the lectures more engaging, and the skills more applicable.  This may also be due to the fact that the course was restructured this year; not having a final exam is an invaluable asset.  Unless you have experience programming in high school, you should definitely take CS50 prior.  Psets still take 8-15 hours per week, though.
CS51 is difficult and time consuming, in addition to impracticalbut it does teach you how to think analytically and logically.
Take 61 instead.
A great class for those that are interested in improving their coding abilities. It does more than just expand your syntactic knowledge, as you are also introduced to skills that are essential to succeeding as a programmer in the real world.
Take it. OCaml and functional programming are fun. Boring lectures and sometimes-tedious psets, but lots of learning
This class teaches you a LOT about writing effective, concise, and tested code. While I entered a class with a basic idea of concepts like modularization and recursion, I came about much more aware of how powerful they are and why functional programming is becoming increasingly popular. There are a lot of reasons to hate OCaml - believe me - but by the end of it, I found it so applicable that switching my mindset to Python (the opposite of a strongly-typed, functional language) proved way more difficult than expected. I think knowing how to program functionally is a great skill. The midterms and psets are generally pretty difficult, but if you have a good partner, it's all manageable. Overall, highly recommend it, although I haven't taken 61 (doing it in the fall!), so I'll have to see how it compares.
Be careful about who is teaching it and be prepared to be unnecessarily confused
This class provides a lot less support and resources than CS50, so you'll have to take the initiative to find the assistance you need. For example, most problem sets were not returned until weeks after they were due. If you waited until then to figure out a concept you didn't quite understand, you'll already be very behind in the course.
As it was the instructor's first year teaching this course, things were a bit rocky. The material was interesting, it was just not always presented effectively.
Easier in 2014 (more late days, more partner psets, no final). Hard work on problem sets but midterms weren't too bad. Final Project interesting. Watch lectures online.
The class teaches you a lot about how to code well and why something is good practice. As such, the course really left me with a feeling that I KNOW what good code should look like and how I can pursue that in further CS classes.
The material in this class is so interesting and ocaml is an amazing language. It is a great way to get introduced to a different (perhaps superior) type  of programming (functional programming). The lectures at times were conducted in such a monotonous fashion that it was very difficult to pay attention. Variable names and syntax were used in a very cryptic way during lectures and sections were pretty useless. The exams were not tricky, but having a  30 question true or false exam for the second midterm? Seriously? A lot of the times this class had organizational problems, especially with grading and some of the less than helpful responses on piazza. However, you do learn very important topics so I would recommend taking this class.
learn stupid ocaml but also useful recursion. concepts are good. class is class.
Solid class. My only issue was with the significant delay in getting problem sets returned which hurt an otherwise fun and challenging introduction to functional programming.
Take it. The tools you learn will be invaluable in later CS courses.
The class is an ok intro class, much better than 50 and sometimes pretty interesting. Functional programming is cool, and it can be pretty sexy. By the way, the tf/staff this year did a really great job--their piazza responses were dead on time, (slight hiccup in grading, but no big deal), and super accommodating. Just a great group of people.
Not at all like CS50, and I mean that in the best way. Lectures aren't gimmicky at all, and while OCaml might seem weird/tricky at first, it's a really beautiful language. The psets are definitely harder - learning functional programming and recursion requires a lot of abstract thinking, and there's an emphasis on finding the BEST solution rather than finding A solution - but as a result they're much more rewarding. A great class!
Functional programming is really important, and you should definitely take this course to learn about it and the OCaml language. However, after you get used to the abnormal syntax of OCaml, you don't really learn much algorithmically in this class. Yes, your abstraction and design will improve, but you will not add to your "algorithmic toolkit." Be careful about your psets. Really take the time to look back at your code and look for ways to optimize, simplify, or abstract it. The grading on psets can be somewhat arbitrary, so do all that is in your power to get good grades on style and design.
I think CS 51 is kind of a turn off class from computer science. I think some of the material is quite interesting, and I really do like and enjoy abstraction. However, I think the teaching staff is often a little unreasonable, and I think I didn't get quite enough knowledge from the class. If you have to take 51, know that you may spend a lot of time worrying about silly things such as styling your code, which imo does reflect knowledge of material. It just feels like bookkeeping, which is not why I wanted to take computer science.
The course does its job well in that the coursework and resources are well-organized and a good challenge. However, I found that there was no support system for those struggling in the course; feedback was always vague or nonexistent, and by the end of the semester, there were no staff members that I felt I could go to for help or guidance. The way grading works, the students who naturally do well are rewarded, while struggling students are easily left behind.
The material for the class is very interesting and the professor is very knowledgable. There is much less support here than in CS50, but it is worth taking if you enjoyed CS50.
cs51 made me enjoy programming but it also killed me for one whole semester. This class is tough - period. Please have enough coding background/experiences before you get in. But you WILL LEARN A LOT, and fall in love with oCaml as long as you DO NOT CROSS THE ABSTRACTION BARRIER.
This is a good course to take if one is interested in learning about functional programming.
The class is taught well; take it if you are interested in learning OCaml specifically
This course is really great for determining whether or not you want to pursue computer science as a concentration. This course was also a great way to learn about key concepts in computer science and general programming, such as abstraction, design, and how to problem-solve.
This class is an introductory computer science class and it shows: from weekly mandatory labs (which were actually okay) to reading checks and required code reviews, this course really tried to hold your hand through the class. While this may be appreciated by some, I really did not like the format of the course at all. In addition to this, problem set grading seemed arbitrary sometimes (in particular, the grading seemed to depend more on who the grader was than the actual code itself), and the teaching fellows were actually quite condescending upon occasion.Looking back, I do not think I would have taken this class if it was not a concentration requirement.
This class is a lot of work, with not that much help. The problem sets are very challenging and the material covered in lecture does not help a great deal in completing the problem sets. Office hours were at inconvenient times, right before the problem sets were due. The Piazza online question forum was also often unhelpful because TFs would respond to questions rather late.
Professor Shieber is funny and engaging, but the grades for this class, primarily based on problem sets, are arbitrary. We received style and design points with very little feedback and very vague criteria.
Ocaml is incredibly frustrating since it uses entirely different syntax from every other language you are likely to use.
This class was very well organized, and taught very well. If you are considering concentrating in computer science, I highly recommend taking this course. You will learn a lot of concepts that CS50 does a poor job of teaching you.
This class pushed me to an uncomfortable amount of mental breakdowns this semester. The workload was unmanageable and I found myself losing contact with friends and family in an effort to finish everything. Moreover, the lack of office hours meant that when I was stuck with a bug in my code (even after spending 10 hours trying to figure it out), I had to wait until 1-2 days before the pset was due which only made stress worse.  I genuinely know no one who enjoyed this class. It felt like the teaching staff was working against students. One example of this was when office hour formats were changed so that you could not show any TF's your code until they had finished answering all conceptual questions. This simply meant that if you had a bug or error that only someone very familiar with ocaml could fix you were left without help. If you have to take this class (read: CS major) then make sure it is the only rigorous course you are taking this semester. Moreover, prepare yourself to lose your mind at times and finish the semester wondering if you will ever find it again.
The psets require a lot of work, and grading on design (I feel) is rather subjective. But overall you will learn a good amount from this class.
Top-notch class. Well taught and well paced. Pretty fast and a fair amount of work, but worth it. Will be fun and rewarding even if you have a significant amount of coding experiencereally, more so if you do. Took after a summer internship but no CS50 and had a nice time.
This class is much harder than CS 50 in my opinion, but I also learned a lot more. I am now thinking a lot more about style and design of my code. Start the final project as early as possible and don't procrastinate on it. It will take a very long time. It may be better to watch lectures online because they can be sleep-inducing when viewed in person. Code review and labs are very helpful, however. Office hours are unfortunately not very helpful except for studying for the exam.
Tough class. Be ready to commit your semester to it.
This class is leagues beyond CS50 in terms of quality. After CS50, I thought I would never enjoy another CS course at Harvard. I was terribly mistaken. This is easily one of the best courses I have ever taken. The amount of material that we learned was immense, and as a non-CS student, I felt that Shieber went at an appropriate and reasonable pace. He is a great lecturer, and he has structured the course so that anyone who puts the time in can succeed. OCaml is a great language to intorudce the various concepts that we explored (polymorphism, algebraic and abstract data types, lazy evaluation, etc.) While it is pretty much impossible to get a solid A in this class (the grading of the PSETS is brutal), I cannot stress enough that you will be a much better programmer and computer scientist for having taken this course. It was truly a wonderful experience.
It is good but sometimes it is bad.
Don't understand why we had to do it in Ocaml. Doesn't help you practically; like no one uses ocaml so you basically learn a useless language instead of learning something valuable.
Ugh. Ugh. Ugh. Honestly, you are marooned on an island and just praying the whole time that a ship will come and pick you up....A ship will never come. Neptune will unleash a hurricane and you'll meet a watery grave. Then the semester will end.
A fun and engaging class, with some tedious elements and grading inconsistency/ambiguity.
This class will definitely help you decide whether you like CS in general, and the way it is taught here in particular.
Pretty good class, not super interesting on the way through, but after writing all of the code in the final project and being forced to understand all the details in the ocaml language semantics, I felt like the material/ocaml finally clicked.  At the very least you will learn how to use important tools like github.
It's a very difficult class that will cause many difficulties to those unprepared.
You'll learn a lot, but you'll also spend a lot of time on this class. It's pretty difficult, but I feel like I understand CS much more than I did after CS50.
This class is extremely difficult even if you did well in CS50. You should ideally have a background in CS if you want to feel comfortable in this class.
You will be a better programmer afterward. Guaranteed.
CS51 is definitely a difficult course, but is very well structured. Make sure to attend labs, as that is where most of my learning took place (in addition to the code reviews).Ultimately, CS51 solidified my intention to concentrate in CS. I had never programmed before taking CS50, and while CS50 was useful as a survey course, CS51 seemed to give me my first taste of what an in-depth computer science course looked like. Would definitely recommend.
The course was extremely interesting and, although quite difficult, I did learn a lot. The final project, unfortunately, seemed to ignore the strengths from the rest of the course, forcing you to work incommunicado on an extremely advanced topic.
For those with a fair amount of CS experience, this class is not very difficult, although the syntax is weird and difficult to get used to at first. For those with less experience, it is definitely not an easy class, but teaches you a lot about the practice of computer science. You learn to be a better coder so don't get caught up with the obscurity of the language.
This class is terrible.
I started off not liking OCaml because I felt like it was a cult, but now that I'm in the cult I've found that it's pretty great.LONG LIVE OCAML
If you care about your grade and you try, you will get a good grade.  If you understand things and finish psets you might not get a good grade, depending on your "participation" and other factors.
The work you have to do is great and satisfying, but the feedback is very poor. It's hard to tell how to improve a grade because they seem to come out of a black hole. However, the content is well worth taking the class.
interesting material, but difficult if not much prior experience
There are probably a lot of other Q Guide evaluations moaning about OCaml being used. This class is very relevant. It teaches you key programming skills. OCaml is really good at illustrating the skills emphasized in this class. Even if you never use the language again, you will get far far better at programming in any language by taking this class.
This course is really designed for people who are very interested in computer science - if you're not really into it, it won't be that great. It's definitely a hard course and some of the assignments can be extremely challenging but there is some support if you're struggling with assignments (definitely make a habit of going to office hours). The material itself is really interesting.
Class is a great class to learn a lot about CS, highly recommend if there is even an outside chance of you taking more CS. Not nearly as hard as people make it out to be and that is coming from someone who has only CS50 as their background in CS before this class.
Prepare to spend half of the semester simply learning the idiosyncrasies of the obscure and unused language that is OCaml; then prepare to realize, once that syntax has finally been learned, that the actual concepts taught in the course - object oriented programming, recursion, time complexity -could have easily been taught in another language like Python or Java, which lend themselves to real application in the field.
I sincerely hope you don't waste your time on this course.  There are so many incredible opportunities at Harvard; please take advantage of these rather than wasting your time here.  If you're a CS concentrator who started with CS50, take CS61 next fall to fulfill your other introduction requirement - I thoroughly enjoyed that class; it's challenging but worthwhile.  If you took CS61 first semester, perhaps you can talk to people in the CS department and attempt to escape the CS51 requirement.  There are several reasons not to take this course, but by far the most pressing is that the primary push of this course isn't teaching functional or object-oriented programming paradigms but is rather teaching how to write code with effective design and style.  These are valuable principles and it is crucial any programmer understand them thoroughly, but this course utterly fails to teach these principles.  Rather than get to the heart of why these principles are important by forcing students to deal with complex programming environments in which design and style are critical to code development, the CS51 course staff have elected to teach design and style by subjecting students to unusually harsh (my standard of comparison is CS61, a course in which I recall one instance in which I was deducted points for design or style) design and style requirements in the process of TF assessment of code.  This decision was and remains disastrous; rather than teaching design and style by motivating its importance through work in a large codebase, students are forced to attempt to predict the incredibly arbitrary criticism of undergraduate course TFs who, it seems, are free to criticize any aspect of students' code's design and style which they dislike.  A style guideline exists for the course, but following this guideline is but a first step; code which adheres to the style guideline perfectly will be subjected to an ill-defined and inconsistent criticism from TFs which teaches nothing and causes incredible concern among students who rightly wish to understand how to improve.  I am not against teaching style - Ive worked with rigorous style guidelines, and I think writing code with good style is crucial.  My criticism with this course is that it assumes not the role of a teacher leading the student to an understanding of why good style and design are necessary but rather of the arbitrary malcontent criticizing a students code for little reason and making no attempt to show the student a path to understanding.
This class is tons of fun. The problem sets are interesting and OCaml is a unique, beautiful language that I enjoyed working in. It was a bit confusing having a new teacher, as we had no idea what to expect on midterms or finals. Also, like a lot of technical classes at Harvard, you'll have no idea what your grade is or how you stack up until grades are released.
As someone who didn't find CS50 all that exciting, I found CS51 to be far more intellectually stimulating. The only issue is that psets are graded kind of late, so it's hard to learn from your mistakes, and the grading rubric seems largely subjective.
CS 51 presented a wide variety of very interesting material (functional, lazy, and object-oriented programming; lambda calculus, meta-circularity, and complexity, etc.) via well-thought-out albeit slow lectures). This was the CS 51 I was looking forward to following CS 50 in the fall. Unfortunately, the CS 51 that I took also entailed mostly unfulfilling problem sets coupled with lackluster and inconsistent grading.This comment was cut off due to length. Find the full text at: https://gist.github.com/anonymous/3fd60509def65ca8dfd06ecba0159a42Recommendations: My recommendation for future students looking to take this course is: dont take it. If you are concentrating in Computer Science, take CS 50 More Comfortable (and challenge yourself to the speller Big Board and to make something cool for your final project) then CS 61 (what looks to be a much more engaging albeit difficult course) to fulfill the baseline requirements. Although CS 61 may seem like a more difficult course, it is more difficult in the right way. The concepts themselves are challenging (and fulfilling) in contrast with CS 51s inconsistent silly nitpicks on overall unfulfilling problems. If you werent planning on concentrating in CS, feel free to audit CS 51. The lectures are great and you can pick the parts of the problem sets that interest you. Auditing cuts out all the tedious stuff and elides all the inconsistency, lack of accountability, and nitpickyness in grading.
This class is less conducive to people who have less experience in coding than some of their peers. You'll be graded off of the same harsh grading standards. It's great for learning OCaml, and it is a fun class, but grade-wise you may not do so well if you're new.
Prepare to devote a sizable portion of your time this semester to this class. Definitely start assignments early and do your best to keep up with lectures rather than read the less helpful textbook. Have extensive and organized notes for the midterms.The course really does give you an appreciation for functional programming and the aesthetics of coding, but can be a lot to handle.
This class isn't for someone who's looking to get a bit of practical CS knowledge so they can code something simple. You'll learn a language that no one uses in real life. It's more for people who are concentrating in CS who are interested in theory/figuring out the building blocks of code. However, I think it's a great critical thinking class. OCaml is kind of counter-intuitive at first, but you'll get the hang of it. If you're very logical and are good at following patterns, this class might be pretty interesting to you.I bought the online PDF versions of the textbooks. It's not great for the open-note tests (I had to print out all the pages which was a supreme waste of paper and not easy to flip through), but the PDF was cheaper than the print version AND easier to find certain sections because you could use the ctrl-F shortcut.
Look at comments on your old psets
Definitely take this course if you are set on CS and interested in learning some very important abstraction concepts. Otherwise, don't since it's a lot of work and very frustrating at times.
Although this class is more well taught and overall better than CS50, it is still extremely difficult. You will spend similar amounts of time as CS50.
It was fun and it exposed me to a completely new language!
This class is useful for learning certain computer science concepts, but it is a time commitment.
Don't be lazy gl
CS51 is a class where you won't get much outside assistance. The partner problem sets are pretty much the only parts where you don't need to know everything and can have someone else help. Other than that, the TFs don't offer much help with anything other than labs.
Put in the effort and you'll be fine. A few of the psets are hell, but overall, not too bad.
Psets are time consuming and help with coding rather than conceptual problems is very limited
There is no class that will hurt your GPA more than this one. As a freshman who has only taken CS50, I would not recommend this class. CS51 is for those who have been coding since birth, or have an extra 15 hours a week to spend debugging an anachronistic language. To its credit, I feel I have become a better programmer because this course made me do a LOT of practice. If your considering CS as a major you need to take it, but if your going for that secondary, spare yourself.
So, you wanna take CS51? So did I! I knew it would be tough, and it was at times, but I didn't know how frustrating their grading is. You can spend 14 hours on a problem set, get all of the correct outputs, and still receive a 75% on your pset because you didn't indent a single line correctly, didn't put a space between a plus sign and two numbers, and didn't use the BEST algorithms for 2 out of 15 functions you write. Geez! The class sucks at times but is overall well done! Don't expect help at office hours.  I learned quite a bit.
A challenging but rewarding functional programming class. At times the tough grading--which is based mostly on code design and style--can become frustrating on problem sets, but Prof. Shieber makes the material interesting enough to make up for course design problems.
This is a hard class that will teach you a ton and make you truly appreciate functional programming/programming in a beautiful manner. However, it has a great deal of issues with very important elements, including a lack of feedback on labs, annoying exams with no faithful practice tests, and a less-than-compelling final project.
Great vlass
This class will test your ability to code. It is a lot different from CS50 in that your code doesn't have to just be right, it has look good, and be designed well. It is definitely manageable and Shieber does a good job of making the material and psets relevant and interesting. I would highly recommend this class to anyone considering a CS concentration as the skills you learn in this class are applicable to almost any other course in CS. Abstraction is an important concept and this course hammers home the importance of abstracting. Labs are great and provide a lot of help with the material. OCaml is a powerful language and fun to use.
If you have any experience in coding at all, this isn't necessary. I didn't even have that (no AP CS, no CS50), and I still don't think it was necessary. I didn't learn anything I couldn't have figured out on my own in a fraction of the time. The emphasis in this class is all over the place, but certainly not on actual programming. Instead of learning, you spend a lot of time worrying about style - how your if statements are indented, if your variable names are acceptable, whether you use two spaces instead of four. It's not worth it. If you want to learn how to code practically, take CS50, then learn on your own. If you want to learn higher level concepts and CS theory, skip this class and take 61/121/124.
CS51 is a natural follow-up to CS50 to those who want to delve further in their CS education. That said, I entered this class thinking I would learn to code beautifully and elegantly. After spending a semester with OCaml, I'm not really sure what was beautiful or elegant about it. Some of the paradigms and concepts taught were helpful, but they did a poor job of elaborating on whether they were just niches of the OCaml programming language or whether they have any purpose or relevance in other programming contexts. The problem sets are difficult and definitely take some time investment, but all of the CS51 TFs are incredible at what they do.
It's not easy but definitely doable
Even if you've taken CS50, consider yourself ill prepared unless you have a solid background in coding.
This is not an easy class, even with a good amount of coding experience. But, it is very rewarding. You learn a lot and learn to frame your thought-process in a very effective way. Lab is VERY useful and Code Review can be very useful. PSets can take time, but also are interesting.
Good course and the material can be fun to figure out at times just be prepared to spend a lot of time towards working on PSets and finishing assignments.
I took CS61 my freshman fall, and this course my freshman spring. Right off the bat, this course was frustrating as hell. After having completed exhilarating software engineering challenges and working on stuff that felt riveting in CS61, CS51's stubborn emphasis on busy work, unreasonable style adherence (I had 20% of style points taken off because one line was indented correctly in a 300-line file), and very narrow style guidelines makes it feel like a waste of time with very little return on investment in terms of knowledge gained. (I learned maybe 20% of what I did in CS61.) I would say, however, that this is unfortunately pretty much the only course that Harvard offers on abstraction techniques and programming paradigms (this is sadly only really looked at towards the end of the course) and so I would probably still take it; it's simply just a low ROI for someone with multiple years of programming experience and a very rewarding experience in a course like CS61. The course gets more and more interesting as the semester progresses, and the ROI certainly goes up -- but be prepared to roll your eyes when the TFs treat you like a baby on Piazza and want to pull your hair out on the first couple of PSETs.
Not a cult, which is a nice change from CS50. However, it's just as hard (maybe harder) than CS50, and problem sets can take a lot of time. Exams are no joke either. Odds are you aren't taking this class for fun though, so just do it. You learn a lot about how to design programs well and it's worthwhile.
CS51 is an incredible class in terms of the material you learn. The psets and labs are fun although time consuming. The lectures are interesting although I recommend sleeping more than 5h on Monday and Wednesday nights so you don't fall asleep in them.  If you have taken CS50 it is the natural next step.
Interesting material.
CS51 is a very interesting course. OCaml is a really cool language and functional programming is really interesting. This class will definitely improve upon your programming abilities.
Don't take with another hard class. Time consuming unless you already know this stuff
51 is nice. OCaml's pretty interesting as a language, and people aren't wrong that you'll think about programming in a different context. It really depends though, because I don't think I've abstracted away from living and started breathing functionally yet.
This class is the next logical step beyond CS50, but with all of the frivolities removed. This 'no bells or whistles' intro CS course will show you what it's really like to program.
Ocaml is actually quite nice
Again, only take if seriously interested in CS, because you will lose all passion for this subject if you are disheartened by the workload.
CS51 characterizes itself as the (much) better version of CS50. This is true for somethings but definitely not for others. For instance, 51 could take a page out of 50's book in terms of office hours. Midway through the course the TFs introduced a new system: conceptual versus code queue. People in the conceptual queue were not allowed to show their laptops to TFs. Basically the TFs would only help people from the conceptual queue, effectively ignoring anyone in the code queue who needed help debugging. This was extremely frustrating. Overall, CS51 has an attitude of "figure it out yourself" that is not at all helpful for people coming in with no more experience than CS50. Another problem happens with grading. The amount of emphasis CS51 puts on style and design rather than correctness of code was extremely frustrating, especially because people would often spend more time trying to make their code look nice than really understand how to write the best functioning program. Overall I really enjoyed the material taught in CS51, and lectures were very interesting. Labs were probably the best part of the course because they helped solidify my understanding of what was taught in lecture. However the grading and exams were extremely discouraging so you should make sure you are really committed to CS before taking a course you have to pour in so much time to get a good grade in.
You learn a different way of thinking - which is useful; however, it is at the cost of grinding through a lot of unit tests.
This class is difficult but very rewarding.  The concepts of abstraction will force you to think in new and interesting ways.  I would recommend this class to anyone who took and enjoyed CS50 or has other similar background in CS.
This class will make you really good at recursive programs. You will come out of this familiar with functional programming, which is cool but also not as useful for internships. Workload is as expected for a CS class. Definitely tougher than CS50.
CS51 was the most difficult and time-consuming class that I had ever taken. Beyond the 20+ hour psets struggling at the extremely packed office hours, I found the time spent on CS51 to be incredibly unrewarding. Despite spending hours on the psets, the resulting scores of design/style (which seem so arbitrary and elusive depending on which TF grades your pset that week) and the correctness unit tests were always disappointing. Additionally, so much time was wasted at office hours from hitting a roadblock, putting your time on the queue to meet with a TF, and then waiting hours only to meet with an unfriendly and unwilling TF who gives you really vague answers.
Just get through it, not particularly useful.
Unless you're taking it for a concentration requirement, I don't think I would recommend it.  The material doesn't seem like it's too applicable, and I don't think the skills you pick up will really bolster your resume down the line.  The class did give me more confidence picking up a new language, which I appreciate; it was tough though.  I feel like people either really struggled with it or thought the class was really easy, and I fell into the former half.
This is a great class, and they run a tight ship. Pay attention to everything you're given in order to keep up (esp. around the introduction of modules, and the final project). My TFs were really terrific, at explaining and at caring about our syntax errors. Lecture content didn't always correlate to to problem sets, which was confusing, and problem sets can take a long time if you have tricky errors. But you will get to code some cool things, like basic webcrawlers and graphs!
It's a class you take if you're seriously considering computer science.
Really interesting course with some cool psets. Decent amount of work but doable with another tough class
Definitely a worthwhile course. Lectures and sections/code reviews can seem kind of useless at times but labs are generally helpful! Also grading on psets is kind of weird but overall, functional programming is a good time!
It is a difficult class and does take time to work through psets. One big thing is that this class does not have as big of a support structure (with office hours, etc.) as CS50 does and to some it can seem like a big leap. If you put the effort into the class and find a good group to pset with, though, it is manageable.
I'm much better at coding design and I understand data structures now! Expect homework assignments that take a long time though.
Definitely take this class as it greatly teaches functional programming.
Be prepared to work without a lot of support from TFs unlike CS50. Office hours are inefficient and the demand for TF help exceeded the supply by a lot. Take relatively easier courses in addition to CS51 because it takes a lot of time
You'll probably never use OCaml again, but this course is still good for learning how to make good design decisions. The labs are really helpful for you to try the topics you learn in lecture, but they'll be fairly difficult if you don't do either the readings or the lectures. Labs are more fun if you collaborate with your assigned partner! The midterms aren't too difficult if you go through the practice tests. The final project is somewhat difficult, so start early (and in general, start early on everything).
This class is really interesting in teaching a new programming mindset. The course is graded kind of harshly in terms of style and design and the final project is difficult. Expect to spend a lot of time on the psets. Lectures are recorded and sometimes not necessary to do the work.
This class takes a lot of time and you definitely need to keep up with lectures. You won't get as much support as you did in CS50 for help on psets, so you definitely need to get good partners for partner psets.
This course is kinda brutal to be honest. There is a complete disconnect between professors and TFs and you will not know what material is on the exam or not. P sets are tough, and can be very tough if you dont start early. They are interesting material. If you fall behind, you are screwed. Highly recommend that you have a little extra background in addition to CS50 for this class. Won't kill you, but not the best experience. Also, why Ocaml?
Take CS181/124 instead if you're relatively good at programming. Too easy
Be prepared for the jump from CS50 to this class
An unpleasant and unfortunately necessary experience. This course teaches a variety of very important and interesting topics that are no doubt fundamental to computer science, but does so in a needlessly tedious and complicated way. There are critical communication errors in teaching staff (the professor gives different directions than the TFs on exams!), no one has a sense of your grade until the very end, and one-on-one help is near impossible to find thanks clogged office hours and busy TFs. You will find much of the stress comes not from the course material but by the course itself. If you could avoid this course I would recommend it, but if it's impossible my best advice is to not panic over your performance relative to others, seeing as grading is seemingly arbitrary and subjective. Just try to enjoy learning some interesting and helpful topics.
You can do well and never show up to anything.
the grading is arbitrary as shit. you will struggle on the last few psets. Solutions for the midterm are not released. Office Hours are way too crowded to go, and the way they run them - not allowing questions on anything but conceptual stuff - is really just a hindrance more than a way of forcing students to really grasp the abstract concepts.
Its a hard class. It is worth it but its a slog.
Professor Shieber and lectures/content were great. Labs were also useful. This class could be a lot more standardized though. I am still not sure how design & style was evaluated because different TFs have told me different things. It's unfortunate but this detracted from the overall experience - I feel like the nitpicky design & style grades turned almost into whether you wrote your code exactly how the particular TF who was grading your work would write it.
Overall, very difficult and very well-taught class. Lectures are fun, problem sets are interesting. Teach staff does a decent job getting students to learn from each other - there are pair programming "labs" and partner problem sets. This class was really hard, but definitely more pleasant than my CS50 experience. Be prepared to put time into the problem sets. TFs seem to do whatever they want during section, so try to find one who focuses on what you are personally looking for during section.
Take this class if you want to learn what programming and CS really is about. CS50 gives you a very hyped-up and gimmicky experience, whereas CS51 will teach you interesting and applicable concepts of abstraction and design in programming, even though OCaml might not be the most common language.
There was absolutely no transparency in everything CS 51-related (grades, problem sets, labs, tests, etc.). Horrible disconnect between quality of teaching from the professor and quality of teaching from TFs. Zero guidance given to us in homeworks; in fact, the TFs were often condescending and rude when we asked them for even the simplest answers. The grading on assignments was 100% arbitrary, with many inconsistencies among TFs. Furthermore, we were forced to adhere to an arbitrary "style guide" after which to model our code, yet the distribution code that the TFs wrote on problem sets did not adhere to this style guide.
I have mixed feelings about this course. On one hand, I really enjoyed it. The problem sets, though time consuming, were typically interesting and engaging. The introduction of labs and partner problem sets made this class enjoyable. I feel like I learned a significant amount of useful information and techniques.However, I spent a lot of time wondering about the "pedagogical choices" that the course made. At times it seemed to me unclear what I was doing wrong, how I should improve, and what sort of work I should aim to produce. With that being said, I enjoyed the class and would likely recommend it, in spite of its flaws.
this is a solid course
Be proactive and reach out to your section leader
Great class that helps you understand some functional aspects of programming very well. Much better than CS50.
Clear and straightforward lectures (if a little bit dry), helpful labs, and reasonable psets.  Sections aren't that helpful but it's only an hour a week.  Psets take a bit longer than CS50 psets, but are graded much harder.  They are quite doable, its just that a lot of emphasis is placed on design and style and those two elements are graded quite harshly.  Not sure what the curve is like, but based on raw scores it's much harder to do well on the psets, even if they really aren't much harder and don't take much longer than CS50 psets (as in the last couple CS50 psets; the first like 5 CS50 psets don't really count).  Overall though an interesting class that teaches you a different style of programming as well as some general programming principles.  Take it if you found CS50 and programming in general interesting.
This code really will make you think about coding. I took this course as my 4th CS course and this was the first one that really forced me to not only code, but code deliberately (didn't take cs50). The only downside is that I wish there could be more examples of how to resolve cases where style rules, design rules, and conciseness conflict.
This course is hard. Especially if you haven't been programming since you were eight years old like a lot of the students taking it. However, it is very doable, you just need to put in the hours. The office hours aren't very helpful - people receive more help from students there than from TFs. The support structure of this course is almost negligible. If you find yourself struggling try to get a tutor. At the end of the course I was proud of the things I had learned and the work I had accomplished. Doing the final project really shows you how much you learn throughout the course, and what you can do if you work hard. It's definitely not for everyone, but I think prospective CS concentrators will enjoy the course. Go to Professor Shieber's office hours and get to know him -- he can seem standoffish from how he acts during lectures and labs, but he is a good guy.
Take it if you have to but don't do so otherwise, skills learned a bit esoteric for non-CS concentrators to benefit from it.
psets are pretty hard, but it'll be the main way you'll learn in this class. the class is pretty challenging, but you get to meet a lot of other students and all the great TFs.
This class is very, very subjective. The same code can be given two different grades based on who's grading. I actually tested this. I went up to two different TFs and asked about a specific part of my code. One said it was great, the other told me to rewrite it in another way if I didn't want to lose points. The subjectiveness cannot be overstated, beware!
Students walking in this class range in ability greatly. This diversity does not change throughout the course. Be prepared to confront long office hours if you are not as familiar with thinking logically as some others are.
This is a great class if you want to learn how to program more efficiently at a fundamental level. CS50 focuses on teaching you to program, while 51 focuses more on teaching you to program well. I did expect a slightly larger focus on how to design programs well, but the psets are fun, engaging and pretty cool overall. The tests, however, are a toss up. There wasn't much material to study this year (bc of the new prof), but next year should be better if Shieber teaches again.
This class teaches you core programming concepts. It's a much better taste of what CS as a concentration is than CS 50.
Not bad if you like programming.
The exams are difficult and the problem sets are heavily weighted on style which makes no sense because functionality and if the code actually works or not is barely graded.
This class is a lot of fun. It is most definitely not CS50, but this does not mean that it is not a great course. It does step up the difficulty from CS50, but if you are paying attention to lectures and attending sections and labs, this class is really not that bad.
This is a very good course for building a conceptual and abstract understanding of CS design. The psets are very interesting, although the grading can be relatively harsh for your adherence to certain style and design guidelines!
This class teaches some really interesting perspectives on computer science, so it is very interesting. The material is presented in a clear and organized way. The hand-holding in cs50 isn't there anymore, so take that into consideration.
If you've had enough CS experience out of high school to skip CS50, you should definitely skip 51 too. It's likely you'll learn next to nothing from the class. The assignments were fairly straightforward, and lectures were informational, but generally not that great. Grading in the class placed what I felt was excessive emphasis on style and design, and scores for those two components were practically arbitrary and very inconsistent between graders. Overall, this course would probably be good to take if you haven't had any CS experience outside of CS50, but would not be worth taking if you've had some exposure to CS from before from high school.
It's a good class, and you learn a lot more than you did in CS50. You won't learn anything that is immediately useful (OCaml is not the most popular language around), but there are higher level topics and habits you'll learn that will be valuable if you continue in computer science. The grading is very frustrating, however, as you will repeatedly get poor marks for functionally correct code, and "no one should get a 5 for design or style." It is also very hard to tell how you are doing in the class overall, as they never communicate what letter grades correspond to grades on psets and midterms. The labs are fun and useful, and the teaching staff is generally very good. Hopefully they go back to an open-ended project in future semesters.
This class is ridiculous. Be prepared for an unreasonable workload and disorganization amongst TFs that creates even more work. Final project specs released w/ tons of mistakes/lack of clarity. Several of my peers who were incredibly on top of their game finished the final project early, after which new information from the TFs was released that made them completely reimplement part of the project, after which said information was taken back, making them reimplement yet again. The schedule of the course is also incredibly annoying and makes reading week/finals truly awful; they "generously" release the project specs early, but have psets running throughout that time so you don't really have time to start it anyways. They then have a "midterm" on the last day of class, so you feel pressure to study for that (the midterms are also incredibly difficult and involve coding in pen along with vague conceptual questions). This means you can't really start the final project until the first day of reading week. The project then takes about 4 or 5 days to complete, effectively wiping out your entire reading week and leaving you no time to study for finals that could be on the first few days of finals week. The midterm-on-the-last-day-of-class + enormous-final-project-during-reading-week combination is terrible and leaves you no time to sleep or prepare for other classes.
I think if you are interested in computer science, you should definitely take this course. This course focuses on recursion and making code efficient, and honestly the stuff is just mind blowing at times. You can do so much with so little code, and the course teaches you how to do it. Shiebs is so good, although he does speak a little slowly. I watched the lectures online and didn't go to class, so I watched them at double speed. Personally I think this is the best move. Overall though, take this course!
If you've just taken CS50 and want to continue with CS, this class is the logical next step. However, if you're deciding between this class and something else, and you're pretty sure you won't take CS very far, take the other course. This class has often demanded 20+ hours for psets, the support and guidance is extremely minimal (for example, during the final project, there was a policy where the TFs refused to help you). The amount of material we covered in such a small time period is also very overwhelming, and be prepared to put in a LOT of work in this class but not necessarily feel like you're getting anywhere.  Labs are really useful, while it is often very hard to keep up with lectures. This is definitely a weeder class.
This class will give you a very different view of programming than CS50 and most of the rest of the Computer Science Department. I think this it is worth taking if you want to pursue CS as a concentration or secondary. That said, I don't think it's the most useful class otherwise. OCaml is not used barely at all in the real world, and so if you don't have an interest in CS, you should not take this class.
Significantly more challenging than CS50, especially towards the end, and especially the midterms. Get started on psets early and you should be okay, but midterms are rough almost no matter what.
this class really helps you get better at thinking about programs.  office hours are terrible, but the problem sets are very doable on your own.  the psets were really fun and well-designed.  would definitely recommend.
Be sure that you are able to dedicate a good amount of time each week to this class. Do not take this as a "side class" unless you are taking it pass-fail. It is more difficult than CS50 for sure, but very rewarding.
Do not take this course unless you are absolutely set on studying CS. The course content is decent, but the teaching staff was very disappointing. And, OCaml is pretty much useless practically.
Grading is very harsh, and problem sets take a long time to complete. Section is helpful, but responses to questions about problem sets and such are usually ambiguous and not very helpful. Exams are also graded harshly, and grade changes are unlikely.
Start psets early, watch lectures
its difficult and a commitment
Lot's of funyou'll learn a lot of new stuff.
A great follow up course from CS50, especially if you had never coded before CS50. Introduces you to many types of programming. Best part: doesn't have any of the bells and whistles of CS50.
Make sure you have a good group of people to pset with or who can help you out with bugs and partner psets.
If CS50 is the only background you have, then be prepared to struggle. However, I enjoyed it a lot more than CS50 as I thought the course was laid out much better and Professor Shieber is the man.
This is a time-intensive but rewarding class.
Start psets early and utilize late days wisely!
I personally love OCaml so I think it's really fun.
Brace yourself. CS50 is not enough preparation for this course. It will take you more than 20 hours a week if cs50 is your only background. Success in this course is more dependent on the partners or groups you work with more than how hard you work. Dont expect any help from the teaching staff. Good luck!
If you are considering going into computer science, CS51 is definitely the course that will tell you if you are up to it. Although it is a weeder course, if you truly enjoy computer science then it is a satisfying course as the PSets offer a decent challenge.
I came to this class with no prior background in CS other than CS 50 and greatly enjoyed the class. It can be a little challenging at times, but totally doable. The course is much more organized than CS 50, and I actually feel like I know something after taking this class. I highly recommend taking this class because the psets and labs are all really fun, and made me more enthusiastic in CS.
Overall, I really enjoyed the work I did for this course. OCaml is really interesting and totally foreign, and if you are passionate about computer science for computer science's sake, then you will enjoy this class, and it will definitely challenge you.That being said, this course was very frustrating, and not for the right reasons. The problem sets are graded based on correctness, design, and style. With respect to design and style, the teaching staff needs to be more clear about what they are looking for. While each problem set would have a few very specific comments about design and style mistakes, the comments were almost universally non-generalizable and therefore not widely applicable. Improving your design and style grade often felt like an impossible task, and I speak not just for myself, but for many of my friends in the course as well. It was quite disheartening.
It's time intensive, but the course staff really cares, and its a much much better intro to programming than CS50. So much better. You will finally, finally learn to program effectively, and understand higher level topics like abstraction and recursion thoroughly. It was a good class, but be prepared to have it be the hardest and most time-intensive class in your schedule. Do not underestimate it, and take advantage of all the resources offered - multiple code reviews, the code review videos, in person lectures, and of course office hours. Use Piazza! Do what you can.
If you don't have to take this class, don't. If you have to take it for a requirement, don't expect it to be pleasant unless your already a coding genius. This is class that had potential to productively continue the introductory coursework of computer science students, but is completely butchered by a terrible structure and teaching staff. It gets to a point where even if you are willing to put in the work and dedicate yourself to bettering your knowledge of the material, it doesn't matter because you have no where to turn. It is likely manageable for someone with extensive CS background, but for anyone else, the label of "introduction" to computer science II with CS50 as the only pre-req is not at all representative of what you will walk in to.
I think this is a very challenging course, but also a good learning opportunity. For those interested in functional programming, this is a wonderful course, but for those who do not have as much of an interest in this topic, the course may not be a good fit.
What you put in for what you get out of the class are not equal
Very interesting and really makes you think. But beware - assignments for this course will take many, many hours and help resources in this course are extremely limited. If you are a CS concentrator, this is a good course to take as it really prepares you to think about the art of computer science differently. If you aren't a CS concentrator, I don't know if it's worth it.
If you are already a CS genius, this course probably isn't for you.
This class is pretty hard, but in my opinion, it is very rewarding and will teach you a lot about how to code well.
Go to office hours early and often and don't procrastinate
If you've never had CS experience, or experience with functional programming, good luck. This course requires a lot of time, you really have to work hard to get good grades -- this means going to office hours, watching lectures, attending sections, and asking for help even after doing all this.
PSets are a lot of fun and you will be learning many practices/tools/concepts in CS just not very deeply. You will learn what "good" design and style generally means.
This is definitely a good course to figure out whether CS is right for you. It can be really frustrating and challenging at times but really forces you to understand what your code is doing and also how to code better.
hard
I found this class very difficult and did not feel like I had the support I needed to be successful in it. there was a big gap between pests and lectures and it was difficult to get help.
You will learn a lot about abstraction and such important programming concepts. However, style and design can be very annoying in this class. While the content is interesting, psets are instructive, and lab is engaging, the grading in the course is very irritating.
This is an excellent course. The teaching staff is dedicated, the material is interesting, and the psets are fun. To the teaching staff: It would be great if some kind of incentive could be implemented for preparing for lab, like a short quiz or finger exercise to be completed before lab based on the reading/lecture. This would make an already good course exceptional.
Know that this course is designed seemingly to weed out people who are not truly interested in pursuing CS. This is not CS50.
Take it, but understand this:-You're not going to learn a useful language. The language of this course is OCaml, a language that most of industry does not use.-You're going to be quite frustrated with the way they grade the style and design of your programs. Be ready for that.
It is difficult but also rewarding. By the end, you feel very comfortable programming in OCaml, and will have a much better sense of design and abstraction. If you took CS50 and it felt too broad and a bit gimmicky, this is the opposite. You will learn one language and approach in depth, and I found this challenging and fun. Of course, it's a lot of work, but not unmanageable at all.
This class is very hard, but the subject matter is worth it and the teaching staff work with you very hard to help you learn it all. Probably not a good idea to take this class with another difficult class at the same time though, because it takes up a lot of time.
Be prepared for this class to take up most of your workload for the semester. Also really be proactive and ask exactly why you're getting the scores you're receiving for style and design on psets because feedback is often very little and grading is very subjective.
Poorly run but you kind of have to take it if you want to be taken seriously as a STEM person. Also watch out on the exams, they are nothing at all like the practice materials. Actual difficulty was v low and ocaml is cool; everything else about the course was Kafkaesque
Definitely quite a big step up from CS50. The way concepts are packaged into OCaml is interesting, but can be quite difficult to understand / apply at first. I highly recommend watching/maybe attending lecture, because when I did it *really* helped (otherwise I was a lost child), and labs are definitely the most useful part of the class.
This class was a concentration requirement for me so there was ultimately no decision on my part for whether I wanted to take it or not. However, it was still an overall good course to take. It was extremely challenging especially with someone with little background in CS in general. Expect to devote many hours each week, utilize office hours well, and get started on assignments early!
This class definitely will take up a lot of your time. It wasn't my hardest class this semester, but it took the most time each week. Office hours are often not very helpful because the queue system of running them is really inefficient. I think it's best to find pset friends that you can bounce ideas off of. This class made me want to pursue a secondary in CS, though administratively I felt like there were some problems.
Take CS50 if you have no background in CS. Also, download the slides, they literally have all the answers that you'll need. But do go to lecture to know where the answers are in these slides.
The class material is foundational to theorhetical computer science and also just programming if you only care about coding and passing an interview. However, the psets are pretty useless. All you need to well is to understand the lab. On the other side, the pset grading is absolutely bad. The grading was arbitrary and varies greatly from one TF to another. Style is such a subjective matter so is design. And most of the time, the style and design the TF thinks are good are just some clever trivial tricks either only applicable in OCaml or not something worthwhile(like improving from O(n) to O(log n)). In fact, if you do something that improves the asymptotical running time, they will take points off because likely doing so takes more lines and they don't like that!!!! What???? So yah, the shorter your code is the better even if it's O(2^n)... Wait, most TFs don't get what that is probably... So overall, the material is foundational but very easy to grasp. But the grading and the TFs are horrendous. If you are smart and competent, just take 124. Don't waste time on this class, but if you are incompetent and still think CS is cool and wanna work at google because that's all you are capable of, take it!
If you're CS you have to take this, so not much to say here.
Take this course. A lot of the previous Q guide reviews say that you need to be a CS whiz in order to succeed in this class but I did not find that to be the case at all. The lectures are not always the most gripping but you learn a lot.
Although this class teaches OCaml, a language that will most likely never be used elsewhere (except Jane Street), it is a very fun class to take!
The concepts learned in CS 51 are quite valuable, and functional programming is a fascinating paradigm to learn about. The class is challenging but interesting, and you touch on a variety of ideas and topics through the problem sets.  I found exams, in particular, to be difficult, and grading, in general, can seem fairly obscure (it can be hard to tell how you are doing in the class).
CS51 has the potential for being a great course, but the staff never defines what they expect clearly, are incoherent in their own code and in their grading, and then are very hard on the students, who all work insanely hard, for not being perfect. Their purposely make their assignments and prompts very confusing and unclear. The assignment are great and you do learn a lot in the class, but there is a lot that can be improved on how they are handled.
While not necessarily the most interesting class, it is incredibly helpful if you want to be a good software engineer!
This is a better choice than 61, but not by much. Grin and bear it to survive this miserable course. The psets are incredibly difficult, graded harshly, and they won't give you any help, even if you ask for it. Ocaml is a terrible language with no applications, so don't get any ideas about using it in your future. They claim the course if useful for learning the "principles" but the only principle I learned was that you should never, ever use Ocaml to try to solve a problem. To hijack a programming saying: "Some people, when confronted with a problem, think 'I know, I'll use [Ocaml].' Now they have two problems."
Going into this course after only taking CS50 is a challenge. There is much less guidance and the teaching staff is not as eager to help.
Do the textbook exercises in the beginning or writing correct OCaml syntax on the test will be impossible.
Don't take it if you don't have to. If you need it as a requirement you'll find it is really interesting material and you definitely come out of it a better coder, but the time commitment probably isn't worth it otherwise. Also the TFs are remarkably unhelpful.
I went into this class slightly spooked by all the doom-and-gloom Q guide reviews from the previous year, but it really was alright! I actually had a lot of fun and feel like I learned a lot. The labs are extremely helpful for solidifying what you hear in lecture on Tuesdays. Definitely try to go to lecture or watch lecture online before lab; you'll get more out of it that way. TFs can be kind of hit-or-missI ended up attending the code review sessions of a different TF because I didn't love the way mine taught. One negative thing about the class is that you will most likely feel like you're not doing well almost the entire time (or maybe that's just me, lol grades haven't come out yet so who knows). You're probably not ever going to see a grade higher than 4/5 style and design, and honestly expect 3/5 and some docked points from the autograder. Kinda discouraging, but the psets are fun. Find a reliable partner for the psets, watch lectures, LEAVE ENOUGH TIME for the psets and final project (lol that last one did me in) and you'll be alright!
Be prepared to spend a long time (>20 hours) on the psets, but don't worry about that too much.  I thought it would absolutely kill me and be unbearable to have a class like that, but I got through it, and it's not tooooo daunting.
Enjoyable, interesting classTFs at office hours are honestly not that helpfulGreat way to bond with your pset partnerHard, time-consuming problem sets
Enjoying and even doing well in CS50 does not at all indicate that one will enjoy or do well in CS51. THIS is the real "weed-out" intro CS class. I've never dropped a class at Harvard, but if I hadn't missed the ad-drop deadline, I definitely would have dropped this one. I'm just happy I survived.
Take this class if you love computer science. Cautiously take this class if you are interested in software engineering. Never take this class if you are concentrating in something other than Computer Science. It's very theoretical and does not provide many applicable programming skills.
You will never need OCaml for the rest of your life, but it was actually a pretty cool/powerful language. However, this class did a terrible job of teaching it. Lectures were incredibly slow and needlessly complicated, obscuring concepts (like recurrence equations) that later seemed obvious in sections. I learned everything I needed to from sections and labs, and didn't even bother watching lectures after the first three weeks of class. Feedback on psets was useless and grades arbitrarily assigned, floating around the 15/20 range for everyone I knew. Start the final project early - and be prepared to deal with the course heads who will answer "read the documentation again" and "you get what you put into it" to any question you lob at them. In summary, I don't regret taking this class as a CS concentrator, but there is absolutely no reason to take it otherwise.
Exams often misgraded and when asked to regrade received the MOST unhelpful/scathing/unnecessary comments ("I suppose this barely scrapes by" was commented when asked why a correct solution received zero credit), unclear feedback/design on psets (often times contradictory to code given with repo), either be less stingy with points or expand style guide for better specificity
If you are considering concentrating in CS and don't know a lot about CS, this is a must-take course. You will learn a lot about how to think about program's efficiency, what is good design, etc.
just know that the grading is ARBITRARY. style and design points may be some of the most frustrating grading metrics ever.
CS51 is a pretty good class. I did feel like the feedback could've been a bit better so that I could improve faster. At times I felt like I was making the same mistakes over and over and didn't quite know why. You do gain a lot of Ocaml knowledge though and various ways to think about your programming (functional vs. imperative)!
Do not take this class unless you definitely want to pursue coding, as the material is interesting, but useless unless you are learning more coding in the future. Also prepare to spend a lot of time in this class.
This class does a good job teaching what is sets out to teach.  Yet, the class' somewhat poorly run assignment and assignment grading system leaves a bad taste in your mouth.
CS51 is an introduction to many interesting paradigms for programming. The majority of the class is about functional programming, which takes some time to wrap your head around, but once you do it becomes actually enjoyable. OCaml is actually a really dope language once you get into it! Some of the psets in this class were actually really fun even though they could take a nontrivial amount of time, and the grading is pretty harsh with regards to style and design, but overall I thought the class was very fair to its students, and it was a lot of fun.
This is a wonderful way to learn about abstraction in language, and does a good job laying the foundation for a solid computer science background.
This is a much more respectable class than CS50.  Prof. Shieber teaches rigorous material, actually provides practical labs to get hands on experience with coding up the concepts learned, and writes reasonable problem sets that do teach the material well.  The psets were, at times, kind of frustrating, but no more so than debugging in any other coding-based course.  I particularly enjoyed the final project, on implementing a parser, because I felt like it was both a fantastic way to learn about programming language semantics, and a bit of a puzzle to figure out.  It really showed that computational linguistics is Prof. Shieber's field of research, because you could tell whoever wrote the spec both really understood this stuff but also really enjoyed it.  It's a shame Shieber (or someone else) isn't planning on teaching CS 187 any time soon, I would certainly take it if it were offered before I graduate.  CS51 is not as flashy as CS50, but it's a much more worthwhile class to take if you want to understand programming and perhaps major in CS here.
Generally a good course and worth doing, teaches useful things about programming. Coursework is quite manageable. Labs aren't really useful at all.
probably not as practical as you might expect.  Don't expect to go code for an internship or a startup after just this.
Make sure you have time for this class, 10-14 hours per week.
This is a good introduction to functional programming.
you will spend a lot of time and love it
The class can be extremely rewarding if you are willing to put the work in. Be prepared to spend a lot of time making your code simpler and simpler and simpler through abstraction - this is both the beauty and challenge that CS51 presents.
This course teaches you functional programming, which is actually a really interesting way of thinking about computation. However, the course's focus on "style" and "design" will wreck your problem set score due to its arbitrariness. That said, the final project is actually really cool, and will give you a good appreciation of functional programming.
This is a good class. I came off of CS50 hating CS as whole but this class really lit a new passion for it. This is the first year Sheiber taught it, and he is really really good.
First the positive: you learn the functional paradigm which is kinda cool. Object orient programming was a tack on, but the point came through. Be prepared for punitive and arbitrary grading as the official policy, We were told off the bat that perfect code should get a 4/5 and this was true. There was no official rubric for grading psets, and so different graders took off points for different things, leaving you guessing. Grading was very late (usually several weeks after the pset) and feedback was scarce. End effect is to make you spend a lot of time checking trivial things. But overall you so learn.
Definitely a course with some deficiencies, but overall I think most people learned a lot. Shieber is a good lecturer, although by the end of the course very few people attend the lectures in person.Cons: The PSETs are somewhat arbitrarily graded (compounded by the non-transparency of the grading). The labs are wholly confusing and not super helpful. Section is not super helpful.Overall, though, would recommend taking the course!
This course isn't worth the grief.
It's a difficult and time consuming class, but you will learn a lot.
Incredible course with Shieber. Lab components make learning concepts much easier because we actually put the concepts into practice before we attempt the HW. Midterm and Final not super difficult but somewhat tricky (but the good kind that tests your mastery of concepts). Some psets do require a ton of time, although most of the difficult ones were partner PSets. Make sure to stay on top of concepts week-to-week and you'll be good.
This class is definitely not CS50.  This class definitely makes you think and learn how to design good algorithms and write very "clean" code.  It's very well organized and Prof. Shieber is a really good lecturer.  If you liked CS50 or thought CS50 didn't make you think enough, take this class.  The psets though, especially the last two or three, as well as the final project can take a lot of time so be aware of that.
If you're just coming out of CS50 and want to learn some more computer science, this course might be for you.  If you're a sophomore with some coding experience looking to learn a bit about functional and object oriented programming, this might be for you.  However, I would not recommend this as an elective to anyone who has much experience programming--it's just not that great a course.
This class is incredibly interesting. While the lectures can sometimes get a bit slow, they are filmed in case you get distracted. The lab portion of the class teaches you a significant amount and the teaching fellows are always present and helping out. The problem sets will have you working with google-esque web crawlers, garageband-esque music files, and even simplified implementations of mL languages themselves. The work is definitely a lot, but I often found the problem sets to be engaging and less work-like. I would definitely recommend if you want to take this class to consider whether or not you have a good friend taking it. The second half of problem sets are all partner-based. Thus, it definitely helped me to know I had a friend I could both rely on to do their share of the work, and know that I wouldn't mind spending multiple hours a week working with them.
As someone who took CS50 and had very little coding experience beyond that, I can speak to the class for people with that level of experience: the exams were scary heading in but ended up being doable once you review the material enough. Some of the psets are definitely much easier for people who've worked with abstract data structures/Java/Python before, but for the most part the course does a good job of transitioning you from the world of CS50 to a world where you can be a real programmer. I definitely recommend finding a good partner for the partner psets and starting work early so you're not behind. Grading is a mystery and not one of the class's strong suits.
This class can be very difficult and a lot of work. However, I learned A LOT about how to code, ways to better write programs, and overall being a better programmer. I think this class is vital to a more general understand of the field of computer science.
Very interesting course! Functions are values and loops are unnecessary! If you like CS, this is your chance to get abstract af!
Take it for a solid course in functional programming that isn't an excessive amount of work as far as CS classes go. You'll learn a fair amount. As far as exams go, don't do the practice ones they give you as they're essentially useless. You'll be far better off re-watching the lectures.
TAKE ITSTUART'S GREATHIS POWERPOINTS ARE GREATLABS ARE GREAT
Professor Shieber made this course really incredible. He's an engaging lecturer, very friendly and enthusiastic, and very fair in his assessments for the course. The psets were challenging but doable, the exams were very fair, and overall the class really makes you appreciate programming as a whole.
Honestly very organized and the best class I have taken
Make sure you are on top of your basic CS knowledge and keep up with readings etc.
I thought it was easier than CS50 just because you had more structure throughout the problem sets. The class is interesting and you will learn functional programming even if it is through OCaml
It's an amazing introduction to programming and a much better way to expose yourself to CS50. About the same amount, if not less, work and you learn so much morel.
This class was a lot of work, especially if you had no CS experience except for CS50 like me. Find a good study group! You will come out with a lot of close friends.
Be prepared to pull an all nighter every now and then. But overall it is SO much better than CS50. Everyone agrees that they learned a lot, and they loved the new instructor's style (Shieber). Shieber focuses more on actual conceptual understandings and his midterms are very problem-solving based and fair.
You definitely should have coded on your own before. On the first day professor asked which processor we used, many people had no idea what he was talking about as their only experience was CS50. Should be more of an Introductory course.
Easier than previous years with Prof. Shieber, it's a great way to learn more about proper CS design and style, as well as a great introduction to a functional programming language.
Take this class if you are curious about functional programming. It's not absolutely essential, so you could just go straight to 124. Nonetheless, I did enjoy this class despite some of the poorly designed problem sets.
Definitely take this class as a follow up to 50 if 50 was interesting. The material is interesting and you definitely learn how to better think like a coder. Psets are challenging but not too crazy. Biggest complaint is that the material isn't that relevant if you're interested in more hands on coding but interesting nonetheless.
Shieber taught this course really well. After hearing some pretty negative things about the course when taught by previous professors, I took this with fairly low expectations, and they were all exceeded. I feel like my understanding of recursion, abstraction, etc. is really solid. Probably should be your 1st or 2nd most important class. Finding a good partner for the psets on the second half of the course is crucial. I really enjoyed the collaborative portion of the course. Feels much more like a real class than cs50.
Much better than CS50
The TFs are wonderful. Make sure to go to lecture or WATCH them online at 2x speed. Professor Shieber speaks slowly (which can seem as if he's not emphasizing information or you may space out), but he covers a lot of good material that's really helpful for psets, exams, and coding in general.
Fun course overall! Take if you know how to code a little bit and like abstraction. If you can learn quickly, problem sets won't take too long and you'll enjoy the course.
CS51 is a difficult course, quite a big jump from CS50. It does take some time to adjust to thinking in terms of functional programming and efficient design, but you will come out of CS51 a much more thoughtful and effective programmer.
OCaml loses it's charm. Don't fall behind, go to lectures, do your labs. Just treat the class seriously and you'll be completely fine.
CS51 is a good class if you are quantitative-minded and want to learn how to code. I think that it is much better taught than CS50 (though, that doesn't say much, because I think CS50 is one of the most poorly-taught classes at the university). I left the class feeling much more comfortable coding, which was the main goal. OCaml doesn't seem to be a super useful language, but you will at least become more comfortable figuring around code, which is important. Functional programming, as a whole, is also interesting theoretically.
If you have been programming since you were in diapers, please move along. If you skipped CS50, you can stop reading now. Go: take this class, thrive, and prosper.For everyone else: this class is not for you. If you were like me and took CS50 the previous semester and thought 'That was hard but I can do it and I like these problems', CS51 is here to weed you out. Apparently even Shieber himself was telling people directly that doing well in CS50 was not enough experience to take CS51. Note to faculty: If a freshman straight out of CS50 does not have enough experience for CS51, something has gone seriously wrong with your numbering system.This class is not intended as an educational experience. It is playtime for the boys who have been programming since birth. If that doesnt describe you, do not take this class. It's not that it's harder than CS50, or comes without the silly bells and whistles (thank God), it is just that it's aimed at a particular group of people which was not me.Kudos to staff for introducing labs though. This must have been hell without those. Though would be great if you became a bit more data-driven and asked for feedback from your hundreds of students as they went through the course, not at the end when nothing could be done about it.
If you don't have a basic grasp of computer science, this may be a useful class for you. However, anyone with better CS skills and knowledge (particularly people who have some degree of experience with functional programming) should probably not take this class, as such people will probably not gain much from this class.I also note that Prof. Shieber was not a very engaging lecturer, and that the class, as it was undergoing transitions, was a little bit shaky at times. Perhaps next year will bring more stability and predictability to the course and its exams.
It is so much better than cs50. Yeah definitely take it if you survived cs50 and are considering taking more cs
Felt easier than CS51, but it was certainly very difficult. Find a good group to do psets with
CS51 was a great class - far superior to CS50.  Unlike CS50, Professor Shieber didn't perform during lectures and thus lectures actually teach you material.  Because most people are unfamiliar with OCaml, the more CS experience you have the better as it will make the transition to a new language much easier.  In terms of workload, there is a lot!  Psets were designed well but required at least ten hours a week if not more.  The most difficult part of the psets was not the coding but understanding how to solve the problem.  Lots of critical thinking is required.  Overall, CS51 has a lot of work and is a hard class, but it is very rewarding.
The class is really really tough, but totally worth your time. Made be both a better programmer, computer user in general.
Material felt interesting and useful. About the same difficulty/time commitment as CS50 if you came in relatively inexperienced. Psets were generally straightforward and didn't always require TF/instructor guidance. Labs and TF office hours were very helpful.
Awesome course!  Lectures can be on the dry side, but the class is so well put together.  Psets are in line with what you learn in the class, labs help cement and preview that material, and code review helps to solidify this as well.  You really learn a ton about writing good, clean, code.
Work hard and make sure you understand everything on the lecture slides as well.
Really does a good job at giving you a foundation in software engineering and programming theory! The psets are pretty easy so it's a nice chill class
The quality of this course probably does depend a lot on who's teaching - in this case, I thought Stuart Shieber was actually quite an effective instructor and I agreed with the way the course was organized (lectures, labs, section). I have nothing against the course, but it can be pretty difficult and as an AM concentrator probably won't be taking more CS courses
It's a very hard class, and you'll definitely need to invest a lot of time into it, but you get what you put into it and it definitely makes you a better programmer! Very fun course with an amazing professor and teaching staff. Labs were excellent because we got to practice what we learned in a more friendly manner.
You get to earn a new language, and a new style of programming! Go to all the labs and code reviews to help you.
Take this course if you don't have a heave course load that semester and also make sure to self-study past what you learned in CS50 if this is going to be your second computer science course.
After CS50 killed my love for CS, CS51 definitely rekindled it. Shieber is a dry lecturer (if you're into sarcastic humor), but explains concepts very well, and this class will definitely make you like functional programming (yay OCaml!). In terms of workload, this class isn't bad because you won't be scrambling to learn a new language each week the way CS50 does, and the office hours are way more structured and helpful. Just start the problem sets early when you can, though they are admittedly doable if you start the night before. The tests were pretty fair, definitely on the easier side.
It's a must-take class for students interested in pursuing computer science and teaches concepts that transcend every subfield of CS and beyond.
Make sure you have a very good understanding of the CS50 material first before taking this class, because having that foundation is really valuable.
I liked the course a lot, especially compared to CS50. There were less arbitrary parts of coding that stopped your progress on problem sets for hours on end. The language itself is a very cool language. Problem sets were enjoyable in that they were kind of like puzzles.
If you are on the fence about computer science, this is the class to take!
you may die in the classbut you'll die with a smile on your face
This course will bring you to a new level of programming and really introduce you to many of the different paradigms and models in the CS.  It really does teach a new way of thinking.
This class is a great introduction to functional programming, which is a totally different style from CS50. It will let you see a different side of CS and help you decide what branch of programming you would like to continue with, if you do.
This course, unlike CS50, will tell you whether you are made for CS. Prepare to put in the same (or more) hours with less help and less hype. Highly recommended if you like programming and you like a good challenge.
Functional programming is awesome and so can you!
Functional programming is actually very interesting. Syllabus is well-organized. Lectures aren't the most engaging, but the weekly labs are very helpful and make sure you don't ever feel completely behind in class material.
CS51 is a lot of work. However, you should be able to get a lot out of the class. Even my friends who had a lot of background had a hard time with certain parts of the course.While the lectures are boring, the course is timed very well, and there's a big support system. Take it!!
I think that this class really helped me to see beauty in computer science, both in the functional programming paradigm and also in well-designed programs. It was just challenging enough, and I think that it provided an introduction to what it is like to study computer science in a more academic and rigorous way than CS 50.
it's very good and teaches you a lot, but course materials could be better. moreover, lectures are pretty boring
It's not easy, but it is immensely satisfying.  You learn a lot about how to program well, and the problems you're asked to solve are actually a lot of fun.
CS50 left a bad taste in my mouth, and I didn't want to do any CS after that. CS51 showed me that CS can be really pretty, and I honestly just want to load up on CS classes from here on out
This class is really great, much better than CS50. You'll actually learn a lot and the lab component of the class will give you an opportunity to ask for help and see if you really understand the readings/what was taught in lecture for a particular week. Office hours can be really helpful, but as you can expect, start your psets early. Some of them will prevent you from sleeping if you wait too long. Take advantage of section, as your TF can be a valuable resource. Overall this class isn't too difficult and it's organized in a way that you don't have to be a programming whiz to do well, but if you already have a solid cs background, you'll be completely fine. Personally one of my favorite classes to date.
Start psets early and go to office hours if you need help.
I honestly did not know what to expect when I came into this class, but it ended up being my favorite class of spring semester! Professor Shieber does an amazing job of teaching concepts and the problem sets are incredibly instructive. Getting to practice the concepts that we learned during weekly labs with the support of TFs was also very helpful. I would really, really highly recommend taking this course, especially if you would like to learn about computer science at a higher level!
The workload for this class is ridiculous. I found CS50 easy, could do the problem sets in ~4 hours usually. This class isn't conceptually challenging but the homework takes over 20 hours per week. Debugging and debugging consumed so much of my time. Do not think it is the same as CS50 at all-- you have to do much more work, and do it yourself. If you take this course i highly recommend not taking it at the same time as other time-intensive Pset classes.
Great class! Much better than CS50!
This is a fantastic class and you definitely get a lot out of it, but you should be prepared to put in a good amount of effort.
I have mixed feelings about this course. I hated the first few weeks of the course. It seemed very disorganized and no one really had any idea what was going on. Then, once things settled down, I ended up enjoying the class. I found the problem sets to be pretty interesting (writing unit tests are a pain though) and in the end you put together a pretty cool final project. I like the lab component of the course, practicing coding with TFs available to help was a much better use of time than a second lecture per week. Shieber is a hilarious guy, but his lectures were really boring in person. However, they're actually pretty good on 2x (or higher) speed, so I'd recommend just watching them after the fact. Take it if you're interested, but don't do it just for kicks.
Make sure to start your problem sets very early. The lab portion is also quite helpful, because the TFs are right there to help with any misunderstandings. Overall, the course teaches you to think very differently than typical programming courses. Functional programming, while not common in the world, can be a very useful teaching too that makes you a better programming and thinker.
Definitly a harder course than CS50 and differs greatly from CS50 in teaching styles. Furthermore this course does a good job in an insight into how CS concentration or further CS courses will be taught
This class is fantastic. I much prefered it to cs50. You finally feel like your programs are legit and you are not blindly trying to do things. A lot of this course focuses on how to code well, and teaches you a new way of thinking. The class was well structured and nothing was too hard. You could tell the coure staff wanted everyone to succeed (ie nothing was made super hard to try to weed people out). Midterm and final were open note and lots of people left early. Shrieber is a decent lecuturer, though if he deviates at all from his notes he gets kind of flustered and is not super good at that.
This course was kind of interesting. I'm very glad I learned functional programming and got to experience another coding class at Harvard. But the lectures, sections, and readings were *completely* useless. All you needed to do well in the class was come to lab and do the psets. Half the people in lecture were asleep because it was boring and slow and often covered material we learned in the last pset. The sections also taught us nothing knew, and the readings taught us what we'd learn soon anyway. You could probably replace coming to labs with readings if you wanted to.This class seemed to deter a lot of people from becoming CS majors. I'm still very into it and thought what we did in the class was quite cool and fun, like puzzle-solving.
Great course.  Lab component was well-done, homework was (for the most part) not overbearing but properly reflected the material learned in lecture.  Lecture was effective.
This class is well-taught and definitely not a waste of time, but be prepared to spend a lot of time working on the psets.
As a math concentrator, I liked this class significantly more than CS50. My one big complaint is it's very back-loaded. Some of the later problem sets, though I wouldn't say they were hard, were extremely time-consuming and tedious and thought the final project was both hard and time-consuming. It definitely felt like CS51 was my only class towards the end and I didn't really like that. Shieber is hilarious and a great lecturer. The concepts are super interesting.
This is a great class and you will learn a lot, but it requires a LOT of time and dedication. You should be ready to commit to a difficult course if you enroll. However, I am grateful I took it despite the time commitment for everything I have learned.
This course will really let you know if you are excited about computer science and its applications in the real world. A lot of the work is tedious and not very fulfilling but overall, the course material is somewhat interesting and this is not a bad course to take.
Great class if thinking about concentrating in CS.
This course is a fantastic experience, though it is hard work, and time consuming. Be prepared for this.
Fantastic course material, although the way it's taught leaves some things to be desired at times. You will leave with a new outlook on information manipulation in the real world (functionally, from data type to data type), as well as a newfound appreciation for elegance in solutions.
I feel like you learn quite a bit in this class, but I also wish they didn't exclusively teach in OCaml.
If you have no programming experience, definitely do 50 first, then 51. It's a really great intro into how to become a good programmer. If you do have programming experience, and are thinking of choosing between 50 and 51, I'd definitely take 51. It'll definitely make your brain work harder, and teach you some stuff which will be valuable in your journey from programmer to computer scientist (recurrence relations, parallel programming, functional programming). If the syllabus sounds beneath you, though, you should talk to a CS adviser about skipping both. It might be mind numbingly easy, and end up feeling like a busy-work laden waste of time.
Professor Shieber is a great professor. The lectures can be a little confusing, but between the other support/meetings of the course, any confusing bits will often be sorted out. Further, the p-sets, tests, and other assignments are really fair (much more favorable than those of the old professor).
Loved it! Takes a lot of time, but very rewarding. Initially, I was dubious, since Ocaml isn't used very much at all in the "real world." However, the concepts we learned were very applicable, and I felt that my problem-solving and programming capabilities significantly improved. This is more than just a functional programming class - it teaches you about best practices in software engineering, e.g. using modules, writing beautiful code, etc. The TFs are great, and the resources available are similarly amazing.
Given this is a required course, you'll probably need to take it regardless of what I say. If you're just looking around to learn, CS51 is much less capable at teaching you to make things. Instead you'll see how some interesting concepts and frameworks function with cows.
Only take it if you need to.
Great course! If you have some programming experience (e.g., AP CS) but missed out on CS50 in the fall (this was my situation), definitely take it, as, in my opinion, this seems to be the first real rigorous introduction course to Computer Science. If you've been able to handle the ultimate basics of a programming language before (I'm talking about for loops, while loops, print statements sort of stuff), you should be fine.
you learn a lot. much of it you may never think about again.
This class was really well taught so it made it as painless an experience as it could be. Know that you will have to spend long hours on the problem sets, especially around the end, but it is actually enjoyable. I can't say enough how well this class was organized with the lectures and the lab component. Stay on top of lectures if possible, but they are always more helpful/clear after the pset so thats just how it is.
I would say that this course is about the same difficulty of CS50, maybe slightly harder. The material, however, is very dry in my opinion, and if you have a hard time focusing and getting work done in boring classes you might have trouble in this class. Make sure to stay on top of the readings, put in your best effort during the labs (it's great practice), and find a good partner (preferably a friend) to work with you on the psets.
Tough class, but hey you learn a lot.
As cheesy as it sounds the course really makes you understand the elegance of programming.
take it, but be prepared
Start everything as early as possible. You'll hear this same advice about basically everything, but it'll always take time to actually figure out the assignments before you can start them.
CS51 is so much fun! Do the psets early and find a solid partner for the partner psets and you will have fun! Functional programming is cool
This isn't CS50. Starting your pset on the last day won't cut it.
After this class you'll either love or hate computer science.
This was the first year that Professor Shieber taught this course and it was already very high quality.  Future years should be even better (and hopefully a little bit harder).  I would definitely recommend it to anyone who wants to continue studying CS after CS 50.  It addresses many concepts to help students grow as programmers and think from a different perspective (i.e. from that of functional programming).  Although the course is taught in OCaml (which is not really used in the real world outside of Jane Street), the concepts you will learn are universal.  Also, significant portions of both imperative and object oriented programming (in addition to functional) will be covered, and OCaml is a good language for getting a unified introduction to all three paradigms.  I think most people would agree that they definitely came out a better thinker as a result of this class.
This class is a good introduction to the functional programming paradigm in OCaml. It won't be too hard if you have prior programming experience. If you don't, it should still be doable, although it will require significantly more effort.
Makes you obsessive over your code, but it also teaches you how to think logically.
This class was a little different this year than in the past- overall great teaching staff and well-run course.
This is a great class, everyone interested in CS should take it. OCaml is a super fun language, and you will learn a lot about program design, though sometimes perhaps a little more implicitly than explicitly. The PSets are great too, not too bad, and very doable if you take the time. The labs are an amazing component of the class, they really help with the concepts. Do the readings, they're very short and very helpful. Office hours fill up quickly, so show up early and have questions ready. Or go early in the week. But yeah, loved this course so much. Take it.
If you want to learn how to code WELL, this is the code to take!
For a lack of a better class at Harvard to take after taking CS50, 51 is probably the right class to take in freshman spring after having taken CS50. The class is mostly useless - it will teach you a language that is used by a very insignificant number of people/companies and you'll probably forget most of the technical stuff you'll learn within a few weeks of learning them.
Great course! I highly recommend it!The exams are fair, and the reading helpful but not essential.Really helps to be good at debugging though! OCaml has a lot of quirky error that can be hard to catch!And, of course, start PSets early!!
The course is well-balanced and very well-taught. The material and lectures are excellent and the problem sets and tests are fair and interesting.
Reading the textbook and coming to lab are both really useful in grasping OCaml. Start the psets early and work with a partner. If you stay up to date on the readings, and meet with your TF whenever you are confused about something, you will be able to do well in the class. Completing psets can be stressful, but that's part of computer science, and starting early and seeking help if you need it will help with this.
CS51 broadened my perspective on coding quite a bit, and I suspect that it made me a much better and more efficient programmer than I was before. For students fresh out of 50: this class does not hold your hand as much and coding strategies are very different. Be ready and eager to explore different ways of solving problems. If you are communicative with TFs about problems you are encountering, you will be able to work through problem sets without trouble.
Good class, much better than cs50
I wasn't going to take this course, but I realized this course was what it took to be where I wanted to be. I took it anyway, and I have no regrets. Take it if you are considering CS.
Ocaml isn't going to be used elsewhere but do not let that make you loos motivation to study hard and deep.
CS51 teaches important and useful programming concepts, but does so in a useless programming language.
Firstly, do not take this course if you have some familiarity with functional programming concepts (like recursion, higher-order functions, and lazy data structures) and with object-oriented programming (at least sufficient to work comfortably with a language like Java), unless you absolutely have to to fulfill concentration requirements, you will not learn anything new. Beyond that I have mixed feelings about the course, on the one hand the material is very interesting if you haven't been exposed to it previously. But on the other hand, the massive logistical issues in the course made it needlessly painful. For example, during the course it was a regular occurrence for the pset code to change on Wednesday for a pset due Friday, often requiring reworkings of previous solutions to account for the changes. Additionally, the pset specifications themselves were often vague and misleading, sometimes referring to code that contained minor, yet noticeable, differences from the code that we were actually working with. Finally, it often seemed like there was a massive disconnect between Professor Shieber and the TFs, as they often seemed unsure about the material and sections of the textbook. While this is understandable, given that this is the first year that Professor Shieber is lecturing the course, the issues I noticed in the course are extremely distracting from the beauty of the material. In the end, however, I can say this: CS51 does a great job of preparing you for real world programming, with its vague and misleading specifications, and constantly shifting codebase.
This is a really good course. I found the concepts much more interesting than those found in CS50. Definitely useful, as well.
This course was extremely well taught.  The problem sets are tough, but we always had the tools at our disposal to work through them.  Office hours are extremely helpful as well as piazza.  Exams are fair and reflect material from lecture and problem sets very well.  Great class overall.
It's better than 50. Better structured, better taught.
Be prepared for boring lectures
This course is a must if you are serious about programming. It is extremely immersive and paints with a broad brush, exposing you to many different concepts and paradigms.
For those of you who weren't enthused with the glitz and glamour of CS50 but want a gradual, smooth introduction to computer science, please take CS51. It stretches your ability to think and follow directions.
It's an amazing course that really allows you to understand computer science at another level. Be prepared to spend hours upon hours every week but if you enjoy grappling with problems, this was a great class that taught me a lot. (Find a group of friends to pset with early!)
This is a wonderful class where you will see many cool ideas and learn about some big, deep ideas in computer science. I highly recommend this class to anyone, but it is important to make sure you have enough time week-by-week to spend on this class in order to get the most out of it.
This class is a lot of fun! It's definitely more interesting, more informative, better structured, and better taught than CS50, so for all those who considered CS but reconsidered after taking CS50, I highly recommend giving CS another shot with this course. However, the biweekly pre-lecture readings are kind of annoying.
If you put in the work, you will come out with a very solid grounding in functional programming
The teaching style and course structure was, for me, much more enjoyable and conducive to learning than CS50. I feel that I learned a lot and would confidently say I could code in OCaml.
This is the next logical step from CS 50
Section was awful this year - didn't help at all with concepts for current psets, just went over last week's pset. Labs were helpful but if you don't attend you will get nothing out of them because they don't give you the right answers after them and you need to guess if you did them correctly. Lecture is helpful, but you need to actually attend.
Schieber runs a good class, and cracks enough jokes for you to endure his otherwise monotonous voice for an entire lecture. It's clear that the TF's and professor really care about the students in this course, and they often go above and beyond to make sure all the students get the help they need. The material is interesting and the Psets are challenging enough to ensure you really understand the material but not unnecessarily onerous or cruel. The exams were fair if not really easy. If you're a CS major, this is a great next step from CS50 to broaden your understanding of what CS really is.
CS51 under Professor Shieber was phenomenal.  The course is nicely laid out, problem sets are manageable, exams are extremely fair, and the tfs are helpful.  Take this class if you want a better understanding of the functional programming dynamic or if you want to broaden your knowledge of CS away from C.
The course is a good introduction to many aspects of the Ocaml language.  Beware:  There are lots of components to the course (lectures, labs, sections, reading surveys, assignments, lab problems, etc.) and it is organizationally challenging to keep track of them all.
This was the first year of Shieber teaching CS 51, and I would reccomend it with reservations. Prof. Shieber is an extremely nice guy, but I thought his lectures could have been better; at least right now, they were extremely boring. Additionally, Office hours were a disaster(Often you had to wait 1-2 hours to get your question answered), and some of the timing for major stuff was off(e.g Midterm on housing day, Final Project due the day of Freshman Formal.That said, some of the content was interesting, and the system was in place to make it a good place(interesting labs, p-sets, reasonable exams).To be honest, though if I could have done it  again, I probably would have just skipped CS 51, and taken 124(also very interesting, better organized, and more applicable).
Apparently a new course head. The labs sure are helpful for students to get comfortable with OCaml. The required final project was probably the worst part of the course, I personally found it uninteresting, even though they set a deadline for alternative projects the day that the final project was announced. Anyways, good structure for the course despite the project seeming to be rushed into the schedule.
I really liked this class. OCaml gets a lot of hate, and while it's true that almost nobody uses it, people do use functional programming which is what OCaml teaches you. We learn good coding practices like abstraction which will make you a better coder. Lots of recursion so if you hated recursion this may not be the class for you. Shieber is engaging. Go to office hours earlier in the week before they get crowded.
Great way to get acquainted to the benefits of the functional paradigms and get yourself thinking about how to tackle difficult problems.
The class was very well organized for such a large class and it was structured very well. However, the class is definitely an introductory class. I took this after taking more challenging classes and I didn't feel like I got that much out of the class. Tim is a great TF, so hopefully you get him.
Would strongly recommend anyone interested in CS take this class! Shieber is a wonderful lecturer and I learned a lot about the beauty of functional programming in this course--OCaml is actually one of my favorite languages now. I think the labs were one of the most helpful parts of the class--you learn the main concepts during lecture, but labs force you to apply your knowledge and really understand the material. Psets weren't too time consuming but were always interesting.
If you enjoy thinking about patterns and solving problems with algorithmic thinking, you will enjoy this class. The problems typically do not involve lots of coding, but you do have to analyze patterns and think deeply about problems to find the right answer. Shieber clearly cared about the class a lot and made sure to teach deliberately. The labs definitely helped me understand the concepts. I really enjoyed CS51, even though it was difficult for me. I would strongly recommend.
take it! fun
This is a hard class, even for people with programming experience. However, you will be just as challenged with or without more than a semester of Computer Science. The topics covered are great and the structure makes this class very well paced.
Go to office hours. Read at least the beginning of the book.
This has definitely been my favorite course thus far at Harvard. The problem sets are all very interesting to solve and even though I spent a lot of time on them I very much enjoyed it.
This is a great course, and a very good introduction to computer science for someone coming from a mathematical background especially (although it is definitely also a great introduction for others as well).
Be sure to enter this class very excited about programming because it will really make you question whether that is something you want to do. Once you do finish it, though, it will be quite rewarding.
excellent course that really taught me a lot about multiple programming paradigms and greatly improved my coding ability and computer science knowledge
Take this class if your are somewhat interested in computer science and have already taken CS50 or another introductory CS course. Honestly, this course was more organized than CS50 and because we concentrated on one language, it was straightforward and the content followed a reasonable progression. Don't worry about the difficulty; if you could do CS50, you can do this!
Good class to learn more about the basics of a language and how it functions within the computer.
This course was very helpful in learning to code in a more independent way than is taught in CS50. Recent changes have made it much more accessible (and much less painful) while still being very informative and interesting.
It's really hard and takes a ton of time, but it's a good class to take if you're considering the concentration. I learned a lot more about what CS is
Programming in Ocaml will first be great; the language is very abstract (in comparison to the monstrosity that is C, for those of you that took CS50) and feels like an almost idealized version of the substitution model. This, however, will only be the case for the first few weeks; then programming in Ocaml becomes a bit of a pain in the back. Nevertheless, Shieber is a strong lecturer and the subject matter of this class is very intriguing.
Only take this class for a concentration requirement. And seriously consider CS61.
This course is pretty boring if you did a lot of coding before. Take with caution because it would not be as rewarding as you might expect.
Great class even if you just want to learn some CS.
Although it seems like the language this course is taught in (OCaml) is not useful, the skills you will learn along the way make the class worthwhile.
This was overall a great class, and I would recommend it to anyone planning to pursue a degree or a secondary in CS. Professor Shieber is a great teacher, albeit he does speak slowly and in a very soothing voice. Take this class. It will be fun even though it is a good amount of work. Also, make sure to get very specific feedback on Design and Style points on problem sets, as that was something I always had trouble figuring out.
Want sexy code? Take CS51.
This is a good course in broadening your understanding of computer science as a whole. However, only enroll in this course if you feel comfortable on every topic covered in CS50.
Really teaches to be a better programmer as opposed to CS50 which just throws random facts at you
As opposed to just being able to program, this class will make you able to program well. It might take a problem set or two to fully snap into the functional programming paradigm, but it is an excellent intellectual opportunity. Once you can think functionally, how to write better algorithms will become much more apparent. Taking this class does not require much prerequisite knowledge. Simply understanding how to program in any language is good enough.
If you've been programming for many years, or even just have had experience with CS before college, I'm sure you'll be fine. If you only took CS50, be prepared to spend prolific amounts of time on this course. I usually only spent around 20-25 hours per week on it, but I talked to someone who spent upward of 50 hours on it each week. So be prepared to spend a lot of time if you're not a natural born programmer. If you are, then great! You'll do well in this class and find it informative. Overall it wasn't terrible, but it was definitely a lot of work -- though you do indeed learn a lot and come out of the class better at what you do.
If you like programming, this is an incredible course to take; I guarantee you that you'll walk out a much better programmer! Plus, this teaches you so much more than CS50, and I'd dare say it would be almost impossible navigating the real world programming market without this class.Make sure you have the time for it though... it's gonna be brutal, and unless you have 20-25 hours a week to spare on a CS problem set, you'll have a mental breakdown. But your mental health is a necessary evil for all the things you'll learn :)
